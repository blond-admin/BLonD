

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>llrf Package &mdash; BLonD 1.1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="BLonD 1.1 documentation" href="../index.html"/>
        <link rel="next" title="monitors Package" href="monitors.html"/>
        <link rel="prev" title="input_parameters Package" href="input_parameters.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> BLonD
          

          
          </a>

          
            
            
              <div class="version">
                1.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="equations_of_motion.html">Equations of Motion</a><ul>
<li class="toctree-l2"><a class="reference internal" href="equations_of_motion.html#definitions">Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="equations_of_motion.html#energy-kick">Energy kick</a></li>
<li class="toctree-l2"><a class="reference internal" href="equations_of_motion.html#arrival-time-drift">Arrival time drift</a></li>
<li class="toctree-l2"><a class="reference internal" href="equations_of_motion.html#the-synchronous-particle">The synchronous particle</a></li>
<li class="toctree-l2"><a class="reference internal" href="equations_of_motion.html#small-amplitude-oscillations">Small-amplitude oscillations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="equations_of_motion.html#tracking-utilities">Tracking utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="equations_of_motion.html#hamiltonian">Hamiltonian</a></li>
<li class="toctree-l2"><a class="reference internal" href="equations_of_motion.html#separatrix">Separatrix</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="lhc_cavity_loop.html">LHC Cavity Loop</a><ul>
<li class="toctree-l2"><a class="reference internal" href="lhc_cavity_loop.html#step-1-calculate-rf-beam-current">STEP 1: Calculate RF beam current</a></li>
<li class="toctree-l2"><a class="reference internal" href="lhc_cavity_loop.html#step-2-cavity-generator-beam-interaction">STEP 2: Cavity-generator-beam interaction</a></li>
<li class="toctree-l2"><a class="reference internal" href="lhc_cavity_loop.html#step-3-rf-feedback-response">STEP 3: RF feedback response</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lhc_cavity_loop.html#analog-feedback">Analog feedback</a></li>
<li class="toctree-l3"><a class="reference internal" href="lhc_cavity_loop.html#digital-feedback">Digital feedback</a></li>
<li class="toctree-l3"><a class="reference internal" href="lhc_cavity_loop.html#one-turn-feedback">One-turn feedback</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lhc_cavity_loop.html#step-4-switch-and-protect-response">STEP 4: Switch and protect response</a></li>
<li class="toctree-l2"><a class="reference internal" href="lhc_cavity_loop.html#step-5-generator-response">STEP 5: Generator response</a></li>
<li class="toctree-l2"><a class="reference internal" href="lhc_cavity_loop.html#step-6-tuner-control">STEP 6: Tuner control</a></li>
<li class="toctree-l2"><a class="reference internal" href="lhc_cavity_loop.html#references">References</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="sps_cavity_loop.html">SPS Cavity Loop</a><ul>
<li class="toctree-l2"><a class="reference internal" href="sps_cavity_loop.html#travelling-wave-cavity">TRAVELLING WAVE CAVITY</a><ul>
<li class="toctree-l3"><a class="reference internal" href="sps_cavity_loop.html#induced-voltage-calculation">Induced-voltage calculation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="sps_cavity_loop.html#the-cavity-controller">THE CAVITY CONTROLLER</a><ul>
<li class="toctree-l3"><a class="reference internal" href="sps_cavity_loop.html#signal-sampling">Signal sampling</a></li>
<li class="toctree-l3"><a class="reference internal" href="sps_cavity_loop.html#low-level-rf">Low-level RF</a></li>
<li class="toctree-l3"><a class="reference internal" href="sps_cavity_loop.html#id1">Generator-induced voltage</a></li>
<li class="toctree-l3"><a class="reference internal" href="sps_cavity_loop.html#id2">Beam-induced voltage</a></li>
<li class="toctree-l3"><a class="reference internal" href="sps_cavity_loop.html#from-coarse-to-fine-grid-and-back">From coarse to fine grid and back</a></li>
<li class="toctree-l3"><a class="reference internal" href="sps_cavity_loop.html#feed-forward">Feed-forward</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="beam.html">beam Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="beam.html#module-blond.beam.beam"><code class="xref py py-mod docutils literal notranslate"><span class="pre">beam</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="beam.html#module-blond.beam.coasting_beam"><code class="xref py py-mod docutils literal notranslate"><span class="pre">coasting_beam</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="beam.html#module-blond.beam.distributions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distributions</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="beam.html#module-blond.beam.distributions_multibunch"><code class="xref py py-mod docutils literal notranslate"><span class="pre">distributions_multibunch</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="beam.html#module-blond.beam.profile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="beam.html#module-blond.beam.sparse_slices"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sparse_slices</span></code> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="impedances.html">impedances Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="impedances.html#module-blond.impedances.impedance"><code class="xref py py-mod docutils literal notranslate"><span class="pre">impedance</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="impedances.html#module-blond.impedances.impedance_sources"><code class="xref py py-mod docutils literal notranslate"><span class="pre">impedance_sources</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="impedances.html#module-blond.impedances.induced_voltage_analytical"><code class="xref py py-mod docutils literal notranslate"><span class="pre">induced_voltage_analytical</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="impedances.html#module-blond.impedances.music"><code class="xref py py-mod docutils literal notranslate"><span class="pre">music</span></code> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="input_parameters.html">input_parameters Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="input_parameters.html#module-blond.input_parameters.rf_parameters"><code class="xref py py-mod docutils literal notranslate"><span class="pre">rf_parameters</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="input_parameters.html#module-blond.input_parameters.ring"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ring</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="input_parameters.html#module-blond.input_parameters.ring_options"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ring_options</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="input_parameters.html#module-blond.input_parameters.rf_parameters_options"><code class="xref py py-mod docutils literal notranslate"><span class="pre">rf_parameters_options</span></code> Module</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">llrf Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-blond.llrf.notch_filter"><code class="xref py py-mod docutils literal notranslate"><span class="pre">notch_filter</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#llrf-beam-feedback-module">llrf.beam_feedback Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#machine-dependent-beam-phase-loop">Machine-dependent Beam Phase Loop</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-blond.llrf.cavity_feedback"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cavity_feedback</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-blond.llrf.impulse_response"><code class="xref py py-mod docutils literal notranslate"><span class="pre">impulse_response</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-blond.llrf.rf_modulation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">rf_modulation</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#llrf-rf-noise-module">llrf.rf_noise Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#rf-phase-noise-generation">RF phase noise generation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#lhc-type-phase-noise-generation">LHC-type phase noise generation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bunch-length-based-feedback-on-noise-amplitude">Bunch-length based feedback on noise amplitude</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-blond.llrf.signal_processing"><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal_processing</span></code> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="monitors.html">monitors Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="monitors.html#module-blond.monitors.monitors"><code class="xref py py-mod docutils literal notranslate"><span class="pre">monitors</span></code> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="plots.html">plots Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="plots.html#module-blond.plots.plot"><code class="xref py py-mod docutils literal notranslate"><span class="pre">plot</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="plots.html#module-blond.plots.plot_beams"><code class="xref py py-mod docutils literal notranslate"><span class="pre">plot_beams</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="plots.html#module-blond.plots.plot_impedance"><code class="xref py py-mod docutils literal notranslate"><span class="pre">plot_impedance</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="plots.html#module-blond.plots.plot_llrf"><code class="xref py py-mod docutils literal notranslate"><span class="pre">plot_llrf</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="plots.html#module-blond.plots.plot_parameters"><code class="xref py py-mod docutils literal notranslate"><span class="pre">plot_parameters</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="plots.html#module-blond.plots.plot_slices"><code class="xref py py-mod docutils literal notranslate"><span class="pre">plot_slices</span></code> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="synchrotron_radiation.html">synchrotron_radiation Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="synchrotron_radiation.html#module-blond.synchrotron_radiation.synchrotron_radiation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">synchrotron_radiation</span></code> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="toolbox.html">toolbox Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="toolbox.html#module-blond.toolbox.action"><code class="xref py py-mod docutils literal notranslate"><span class="pre">action</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="toolbox.html#module-blond.toolbox.diffusion"><code class="xref py py-mod docutils literal notranslate"><span class="pre">diffusion</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="toolbox.html#module-blond.toolbox.filters_and_fitting"><code class="xref py py-mod docutils literal notranslate"><span class="pre">filters_and_fitting</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="toolbox.html#module-blond.toolbox.logger"><code class="xref py py-mod docutils literal notranslate"><span class="pre">logger</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="toolbox.html#module-blond.toolbox.next_regular"><code class="xref py py-mod docutils literal notranslate"><span class="pre">next_regular</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="toolbox.html#module-blond.toolbox.parameter_scaling"><code class="xref py py-mod docutils literal notranslate"><span class="pre">parameter_scaling</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="toolbox.html#module-blond.toolbox.tomoscope"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tomoscope</span></code> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="trackers.html">trackers Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="trackers.html#module-blond.trackers.tracker"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tracker</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trackers.html#module-blond.trackers.utilities"><code class="xref py py-mod docutils literal notranslate"><span class="pre">utilities</span></code> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="compile.html">compile Module</a><ul>
<li class="toctree-l2"><a class="reference internal" href="compile.html#id1"><code class="xref py py-mod docutils literal notranslate"><span class="pre">compile</span></code> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="utils.html">utils Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="utils.html#module-blond.utils.bmath"><code class="xref py py-mod docutils literal notranslate"><span class="pre">bmath</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="utils.html#module-blond.utils.bphysics_wrap"><code class="xref py py-mod docutils literal notranslate"><span class="pre">bphysics_wrap</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="utils.html#module-blond.utils.butils_wrap"><code class="xref py py-mod docutils literal notranslate"><span class="pre">butils_wrap</span></code> Module</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>
    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">BLonD</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>llrf Package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/modules/llrf.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="llrf-package">
<h1>llrf Package<a class="headerlink" href="#llrf-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-blond.llrf.notch_filter">
<span id="notch-filter-module"></span><h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">notch_filter</span></code> Module<a class="headerlink" href="#module-blond.llrf.notch_filter" title="Permalink to this headline">¶</a></h2>
<p><strong>Method to apply a notch filter to a specified impedance source</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Authors</dt>
<dd class="field-odd"><p><strong>Danilo Quartullo</strong></p>
</dd>
</dl>
<dl class="py function">
<dt id="blond.llrf.notch_filter.impedance_notches">
<code class="sig-prename descclassname">blond.llrf.notch_filter.</code><code class="sig-name descname">impedance_notches</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f_rev</span></em>, <em class="sig-param"><span class="n">frequencies</span></em>, <em class="sig-param"><span class="n">imp_source</span></em>, <em class="sig-param"><span class="n">list_harmonics</span></em>, <em class="sig-param"><span class="n">list_width_depth</span></em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.notch_filter.impedance_notches" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="llrf-beam-feedback-module">
<h2>llrf.beam_feedback Module<a class="headerlink" href="#llrf-beam-feedback-module" title="Permalink to this headline">¶</a></h2>
<p><strong>Various beam phase loops (PL) with optional synchronisation (SL), frequency
(FL), or radial loops (RL) for the CERN machines</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Authors</dt>
<dd class="field-odd"><p><strong>Helga Timko</strong></p>
</dd>
</dl>
<div class="section" id="machine-dependent-beam-phase-loop">
<h3>Machine-dependent Beam Phase Loop<a class="headerlink" href="#machine-dependent-beam-phase-loop" title="Permalink to this headline">¶</a></h3>
<dl class="py class">
<dt id="blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop">
<em class="property">class </em><code class="sig-prename descclassname">llrf.phase_loop.</code><code class="sig-name descname">PhaseLoop</code><span class="sig-paren">(</span><em class="sig-param">object).__init__(GeneralParameters</em>, <em class="sig-param">RFSectionParameters</em>, <em class="sig-param">Slices</em>, <em class="sig-param">gain</em>, <em class="sig-param">gain2 = 0</em>, <em class="sig-param">machine = 'LHC'</em>, <em class="sig-param">period = None</em>, <em class="sig-param">window_coefficient = 0</em>, <em class="sig-param">coefficients = None</em>, <em class="sig-param">PhaseNoise = None</em>, <em class="sig-param">LHCNoiseFB = None</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop" title="Permalink to this definition">¶</a></dt>
<dd><p>One-turn PL for different machines with different hardware. The beam phase is
calculated as the convolution of the beam profile with the RF wave of the
main harmonic system (corresponding to a band-pass filter). The PL acts
directly on the RF frequency and phase of all harmonics.</p>
<p>Some machine-dependent features:</p>
<ul class="simple">
<li><p>PSB: use <code class="docutils literal notranslate"><span class="pre">sampling_frequency</span></code> for a PL that is active only at certain
turns.</p></li>
<li><p>SPS: use <code class="docutils literal notranslate"><span class="pre">window</span> <span class="pre">coefficient</span></code> to sample beam phase over a suitable
amount of bunches (<code class="docutils literal notranslate"><span class="pre">window_coefficient</span> <span class="pre">=</span> <span class="pre">0</span></code> results in single-bunch
acquisition as in the LHC)</p></li>
<li><p>LHC_F: PL with optional FL (use <code class="docutils literal notranslate"><span class="pre">gain2</span></code> to activate)</p></li>
<li><p>LHC: PL with optional SL (use <code class="docutils literal notranslate"><span class="pre">gain2</span></code> to activate; note that gain is
frequency dependent)</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>GeneralParameters</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">input_parameters.general_parameters.GeneralParameters</span></code></p></li>
<li><p><strong>RFSectionParameters</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">input_parameters.rf_parameters.RFSectionParameters</span></code></p></li>
<li><p><strong>Slices</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">beams.slices.Slices</span></code></p></li>
<li><p><strong>gain</strong> (<em>double</em>) – phase loop gain [1/ns], typically <span class="math notranslate nohighlight">\(\sim 1/(10 T_0)\)</span></p></li>
<li><p><strong>gain2</strong> (<em>double</em>) – FL gain [turns] or SL gain [1/ns], depending on machine;
typically ~10 times weaker than PL</p></li>
<li><p><strong>machine</strong> (<em>str</em>) – machine name, determines PL choice</p></li>
<li><p><strong>period</strong> (<em>double</em>) – optional for PSB: period of PL being active</p></li>
<li><p><strong>window_coefficient</strong> (<em>double</em>) – window coefficient for band-pass filter
determining beam phase; use 0 for single-bunch acquisition</p></li>
<li><p><strong>coefficients</strong> (<em>array</em>) – optional for PSB: PL transfer function
coefficients</p></li>
<li><p><strong>PhaseNoise</strong> – optional: phase-noise type class for noise injection
through the PL,
<code class="xref py py-class docutils literal notranslate"><span class="pre">llrf.rf_noise.PhaseNoise</span></code> or
<code class="xref py py-class docutils literal notranslate"><span class="pre">llrf.rf_noise.LHCFlatSpectrum</span></code></p></li>
<li><p><strong>LHCNoiseFB</strong> – optional: bunch-length feedback class for phase noise
<code class="xref py py-class docutils literal notranslate"><span class="pre">llrf.rf_noise.LHCNoiseFB</span></code></p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop.track">
<code class="sig-name descname">track</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop.track" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the PL correction on main RF frequency depending on machine.
Updates the RF phase and frequency of the next turn for all RF systems.</p>
<p>Let <span class="math notranslate nohighlight">\(\Delta \omega_{\mathsf{TOT}}\)</span> be the total frequency correction
(calculation depends on the machine, see below). The RF frequency of a
given RF system <span class="math notranslate nohighlight">\(i\)</span> is then shifted by</p>
<div class="math notranslate nohighlight">
\[\Delta \omega_{\mathsf{rf},i} = \frac{h_i}{h_0} \Delta
\omega_{\mathsf{TOT}} ,\]</div>
<p>with a corresponding RF phase shift of</p>
<div class="math notranslate nohighlight">
\[\Delta \varphi_{\mathsf{rf},i} = 2 \pi h_i
\frac{\omega_{\mathsf{rf},i}}{\Omega_{\mathsf{rf},i}} ,\]</div>
<p>where <span class="math notranslate nohighlight">\(\Omega_{\mathsf{rf},i} = h_i \omega_0\)</span> is the design
frequency and <span class="math notranslate nohighlight">\(\omega_{\mathsf{rf},i}\)</span> the actual RF frequency
applied.</p>
</dd></dl>

<dl class="py method">
<dt id="blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop.precalculate_time">
<code class="sig-name descname">precalculate_time</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">GeneralParameters</span></em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop.precalculate_time" title="Permalink to this definition">¶</a></dt>
<dd><p>For PSB, where the PL acts only with a given periodicity, pre-calculate on
which turns to act.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>GeneralParameters</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">input_parameters.general_parameters.GeneralParameters</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop.beam_phase">
<code class="sig-name descname">beam_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop.beam_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Beam phase measured at the main RF frequency and phase. The beam is
convolved with the window function of the band-pass filter of the machine.
The coefficients of sine and cosine components determine the beam phase,
projected to the range -Pi/2 to 3/2 Pi.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>that this beam phase is already determined w.r.t. the
instantaneous RF phase.</p>
</div>
<p>The band-pass filter modelled assumes a window function of the form</p>
<div class="math notranslate nohighlight">
\[W(t) = e^{-\alpha t}
\cos(\omega_{\mathsf{rf}} t - \varphi_{\mathsf{rf}}) ,\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha\)</span> is the <code class="docutils literal notranslate"><span class="pre">window_coefficient</span></code> that determines how
many bunches are taken into account.</p>
<p>The convolution of <span class="math notranslate nohighlight">\(W(t)\)</span> with the bunch profile <span class="math notranslate nohighlight">\(\lambda(t)\)</span>
results in two components,</p>
<div class="math notranslate nohighlight">
\[f(t) = \int_{\lambda_{\mathsf{min}}}^{\lambda_{\mathsf{max}}}
{e^{-\alpha (t-\tau)} \cos(\omega_{\mathsf{rf}} (t-\tau) -
\varphi_{\mathsf{rf}}) \lambda(\tau) d\tau}
= e^{-\alpha t} \cos(\omega_{\mathsf{rf}} t)
\int_{\lambda_{\mathsf{min}}}^{\lambda_{\mathsf{max}}}
{e^{\alpha \tau} \cos(\omega_{\mathsf{rf}} \tau +
\varphi_{\mathsf{rf}}) \lambda(\tau) d\tau}
+ e^{-\alpha t} \sin(\omega_{\mathsf{rf}} t)
\int_{\lambda_{\mathsf{min}}}^{\lambda_{\mathsf{max}}}
{e^{\alpha \tau} \sin(\omega_{\mathsf{rf}} \tau +
\varphi_{\mathsf{rf}}) \lambda(\tau) d\tau} .\]</div>
<p>The beam phase is determined from the coefficients of the sine and cosine
components, i.e.</p>
<div class="math notranslate nohighlight">
\[\varphi_b \equiv \arctan \left(
\frac{\int_{\lambda_{\mathsf{min}}}^{\lambda_{\mathsf{max}}}
{e^{\alpha \tau} \sin(\omega_{\mathsf{rf}} \tau +
\varphi_{\mathsf{rf}}) \lambda(\tau) d\tau}}
{\int_{\lambda_{\mathsf{min}}}^{\lambda_{\mathsf{max}}}
{e^{\alpha \tau} \cos(\omega_{\mathsf{rf}} \tau +
\varphi_{\mathsf{rf}}) \lambda(\tau) d\tau}} \right) .\]</div>
<p>This projects the beam phase to the interval
<span class="math notranslate nohighlight">\(\left( -\frac{\pi}{2} , \frac{\pi}{2}\right)\)</span>, however, the RF
phase is defined on the interval
<span class="math notranslate nohighlight">\(\left( -\frac{\pi}{2} , \frac{3 \pi}{2}\right)\)</span>. In order to get a
correct measurement of the beam phase, we thus add <span class="math notranslate nohighlight">\(\pi\)</span> if the
cosine coefficient is negative (meaning normally the beam energy is above
transition).</p>
</dd></dl>

<dl class="py method">
<dt id="blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop.phase_difference">
<code class="sig-name descname">phase_difference</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop.phase_difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Phase difference between beam and RF phase of the main RF system.
Optional: add RF phase noise through dphi directly.</p>
<p>As the actual RF phase is taken into account already in the beam phase
calculation, only the synchronous phase needs to be substracted and thus
the phase difference seen by the PL becomes</p>
<div class="math notranslate nohighlight">
\[\Delta \varphi_{\mathsf{PL}} = \varphi_b - \varphi_s .\]</div>
<p>If phase noise is injected through the PL, it is added directly as an
offset to this measurement, optionally with the feedback scaling factor
<span class="math notranslate nohighlight">\(x\)</span>.</p>
<div class="math notranslate nohighlight">
\[\Delta \varphi_{\mathsf{PL}} = \varphi_b - \varphi_s
+ (x) \phi_N .\]</div>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">LHC_F():</code></dt>
<dd><p>Calculates the RF frequency correction <span class="math notranslate nohighlight">\(\Delta \omega_{\mathsf{PL}}\)</span>
from the phase difference between beam and RF
<span class="math notranslate nohighlight">\(\Delta \varphi_{\mathsf{PL}}\)</span> for the LHC. The transfer function is</p>
<div class="math notranslate nohighlight">
\[\Delta \omega_{\mathsf{PL}} = - g_{\mathsf{PL}}
\Delta\varphi_{\mathsf{PL}} ,\]</div>
<p>Using ‘gain2’, the frequency loop can be activated in addition to remove
long-term frequency drifts:</p>
<div class="math notranslate nohighlight">
\[\Delta \omega_{\mathsf{FL}} = - g_{\mathsf{FL}}
(\omega_{\mathsf{rf}} - h \omega_{0}) .\]</div>
</dd></dl>

<dl class="py method">
<dt id="blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop.LHC">
<code class="sig-name descname">LHC</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop.LHC" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the RF frequency correction <span class="math notranslate nohighlight">\(\Delta \omega_{\mathsf{PL}}\)</span>
from the phase difference between beam and RF
<span class="math notranslate nohighlight">\(\Delta \varphi_{\mathsf{PL}}\)</span> for the LHC. The transfer function is</p>
<div class="math notranslate nohighlight">
\[\Delta \omega_{\mathsf{PL}} = - g_{\mathsf{PL}}
\Delta \varphi_{\mathsf{PL}} ,\]</div>
<p>Using ‘gain2’, a synchro loop can be activated in addition to remove
long-term frequency and phase drifts:</p>
<div class="math notranslate nohighlight">
\[\Delta \omega_{\mathsf{SL}} = - g_{\mathsf{SL}}
(y + a \, \Delta \varphi_{\mathsf{rf}}) ,\]</div>
<p>where <span class="math notranslate nohighlight">\(\Delta \varphi_{\mathsf{rf}}\)</span> is the accumulated RF phase
deviation from the design value and <span class="math notranslate nohighlight">\(y\)</span> is is obtained through the
recursion (<span class="math notranslate nohighlight">\(y_0 = 0\)</span>)</p>
<div class="math notranslate nohighlight">
\[y_{n+1} = (1 - \tau) y_n + (1 - a) \tau
\Delta \varphi_{\mathsf{rf}} .\]</div>
<p>The variables <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(\tau\)</span> are being defined through the
(single-harmonic, central) synchrotron frequency <span class="math notranslate nohighlight">\(f_s\)</span> and the
corresponding synchrotron tune <span class="math notranslate nohighlight">\(Q_s\)</span> as</p>
<div class="math notranslate nohighlight">
\[a (f_s) \equiv 5.25 - \frac{f_s}{\pi 40~\text{Hz}} ,\]</div>
<div class="math notranslate nohighlight">
\[\tau(f_s) \equiv 2 \pi Q_s \sqrt{ \frac{a}{1 +
\frac{g_{\mathsf{PL}}}{g_{\mathsf{SL}}} \sqrt{\frac{1 + 1/a}{1 + a}} }} .\]</div>
</dd></dl>

<dl class="py method">
<dt>
<code class="sig-name descname">PSB():</code></dt>
<dd><p>Phase loop:</p>
<p>The transfer function of the system is</p>
<div class="math notranslate nohighlight">
\[H(z) = g \frac{b_{0}+b_{1} z^{-1}}{1 +a_{1} z^{-1}}\]</div>
<p>where g is the gain and <span class="math notranslate nohighlight">\(b_{0} = 0.99901903\)</span>, <span class="math notranslate nohighlight">\(b_{1} = -0.99901003\)</span>,
<span class="math notranslate nohighlight">\(a_{1} = -0.99803799\)</span>.</p>
<p>Let <span class="math notranslate nohighlight">\(\Delta \phi_{PL}\)</span> and <span class="math notranslate nohighlight">\(\Delta \omega_{PL}\)</span> be the
phase difference and the phase loop correction on the frequency
respectively; since these two quantities are the input and output of our
system, then from the transfer function we
have in time domain (see <a class="reference external" href="https://en.wikipedia.org/wiki/Z-transform">https://en.wikipedia.org/wiki/Z-transform</a>):</p>
<div class="math notranslate nohighlight">
\[\Delta \omega_{PL}^{n+1} = - a_{1} \Delta \omega_{PL}^{n} +
g(b_{0} \Delta \phi_{PL}^{n+1} + b_{1} \Delta \phi_{PL}^{n})\]</div>
<p>In fact the phase and radial loops act every 10 <span class="math notranslate nohighlight">\(\mu s\)</span> and as a
consequence <span class="math notranslate nohighlight">\(\Delta \phi_{PL}\)</span> is an average on all the values
between two trigger times.</p>
<p>Radial loop:</p>
<p>We estimate
the difference of the radii of the actual trajectory and the desired trajectory
using one of the four known differential relations with <span class="math notranslate nohighlight">\(\Delta B = 0\)</span>:</p>
<div class="math notranslate nohighlight">
\[\frac{\Delta R}{R} = \frac{\Delta \omega_{RF}}{\omega_{RF}}
\frac{\gamma^2}{\gamma_{T}^2-\gamma^2}\]</div>
<p>In reality the error <span class="math notranslate nohighlight">\(\Delta R\)</span> is filtered with a PI (Proportional-
Integrator) corrector. This means that</p>
<div class="math notranslate nohighlight">
\[\Delta \omega_{RL}^{n+1} = K_{P} \left(\frac{\Delta R}{R}\right)^{n}
+ K_{I} \int_0^n \! \frac{\Delta R}{R} (t) \, \mathrm{d}t.\]</div>
<p>Writing the same equation for <span class="math notranslate nohighlight">\(\Delta \omega_{RL}^{n}\)</span> and
subtracting side by side we have</p>
<div class="math notranslate nohighlight">
\[\Delta \omega_{RL}^{n+1} = \Delta \omega_{RL}^{n} +
K_{P} \left[ \left(\frac{\Delta R}{R}\right)^{n} -
\left(\frac{\Delta R}{R}\right)^{n-1} \right] + K_{I}^{'}
\left(\frac{\Delta R}{R}\right)^{n}\]</div>
<p>here <span class="math notranslate nohighlight">\(K_{I}^{'} = K_{I} 10 \mu s\)</span> and we approximated the integral
with a simple product.</p>
<p>The total correction is then</p>
<div class="math notranslate nohighlight">
\[\Delta \omega_{RF}^{n+1} = \Delta \omega_{PL}^{n+1} + \Delta \omega_{RL}^{n+1}\]</div>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-blond.llrf.cavity_feedback">
<span id="cavity-feedback-module"></span><h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">cavity_feedback</span></code> Module<a class="headerlink" href="#module-blond.llrf.cavity_feedback" title="Permalink to this headline">¶</a></h2>
<p><strong>Various cavity loops for the CERN machines</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Authors</dt>
<dd class="field-odd"><p><strong>Helga Timko</strong></p>
</dd>
</dl>
<dl class="py class">
<dt id="blond.llrf.cavity_feedback.CavityFeedbackCommissioning">
<em class="property">class </em><code class="sig-prename descclassname">blond.llrf.cavity_feedback.</code><code class="sig-name descname">CavityFeedbackCommissioning</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">debug</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">open_loop</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">open_FB</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">open_drive</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">open_FF</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.CavityFeedbackCommissioning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

<dl class="py class">
<dt id="blond.llrf.cavity_feedback.SPSCavityFeedback">
<em class="property">class </em><code class="sig-prename descclassname">blond.llrf.cavity_feedback.</code><code class="sig-name descname">SPSCavityFeedback</code><span class="sig-paren">(</span><em class="sig-param">RFStation</em>, <em class="sig-param">Beam</em>, <em class="sig-param">Profile</em>, <em class="sig-param">G_ff=1</em>, <em class="sig-param">G_llrf=10</em>, <em class="sig-param">G_tx=0.5</em>, <em class="sig-param">a_comb=0.9375</em>, <em class="sig-param">turns=1000</em>, <em class="sig-param">post_LS2=True</em>, <em class="sig-param">V_part=None</em>, <em class="sig-param">Commissioning=&lt;blond.llrf.cavity_feedback.CavityFeedbackCommissioning object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSCavityFeedback" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class determining the turn-by-turn total RF voltage and phase correction
originating from the individual cavity feedbacks. Assumes two 4-section and
two 5-section travelling wave cavities in the pre-LS2 scenario and four
3-section and two 4-section cavities in the post-LS2 scenario. The voltage
partitioning is proportional to the number of sections.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RFStation</strong> (<em>class</em>) – An RFStation type class</p></li>
<li><p><strong>Beam</strong> (<em>class</em>) – A Beam type class</p></li>
<li><p><strong>Profile</strong> (<em>class</em>) – A Profile type class</p></li>
<li><p><strong>G_llrf</strong> (<em>float</em><em> or </em><em>list</em>) – LLRF Gain [1]; if passed as a float, both 3- and 4-section (4- and
5-section) cavities have the same G_llrf in the post- (pre-)LS2
scenario. If passed as a list, the first and second elements correspond
to the G_llrf of the 3- and 4-section (4- and 5-section) cavity
feedback in the post- (pre-)LS2 scenario; default is 10</p></li>
<li><p><strong>G_tx</strong> (<em>float</em><em> or </em><em>list</em>) – Transmitter gain [1] of the cavity feedback; convention same as G_llrf;
default is 0.5</p></li>
<li><p><strong>a_comb</strong> (<em>float</em>) – Comb filter ratio [1]; default is 15/16</p></li>
<li><p><strong>turns</strong> (<em>int</em>) – Number of turns to pre-track without beam</p></li>
<li><p><strong>post_LS2</strong> (<em>bool</em>) – Activates pre-LS2 scenario (False) or post-LS2 scenario (True); default
is True</p></li>
<li><p><strong>V_part</strong> (<em>float</em>) – Voltage partitioning of the shorter cavities; has to be in the range
(0,1). Default is None and will result in 6/10 for the 3-section
cavities in the post-LS2 scenario and 4/9 for the 4-section cavities in
the pre-LS2 scenario</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="blond.llrf.cavity_feedback.SPSCavityFeedback.OTFB_1">
<code class="sig-name descname">OTFB_1</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSCavityFeedback.OTFB_1" title="Permalink to this definition">¶</a></dt>
<dd><p>An SPSOneTurnFeedback type class; 3/4-section cavity for post/pre-LS2</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>class</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="blond.llrf.cavity_feedback.SPSCavityFeedback.OTFB_2">
<code class="sig-name descname">OTFB_2</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSCavityFeedback.OTFB_2" title="Permalink to this definition">¶</a></dt>
<dd><p>An SPSOneTurnFeedback type class; 4/5-section cavity for post/pre-LS2</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>class</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="blond.llrf.cavity_feedback.SPSCavityFeedback.V_sum">
<code class="sig-name descname">V_sum</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSCavityFeedback.V_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Vector sum of RF voltage from all the cavities</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="blond.llrf.cavity_feedback.SPSCavityFeedback.V_corr">
<code class="sig-name descname">V_corr</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSCavityFeedback.V_corr" title="Permalink to this definition">¶</a></dt>
<dd><p>RF voltage correction array to be applied in the tracker</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="blond.llrf.cavity_feedback.SPSCavityFeedback.phi_corr">
<code class="sig-name descname">phi_corr</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSCavityFeedback.phi_corr" title="Permalink to this definition">¶</a></dt>
<dd><p>RF phase correction array to be applied in the tracker</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="blond.llrf.cavity_feedback.SPSCavityFeedback.logger">
<code class="sig-name descname">logger</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSCavityFeedback.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>Logger of the present class</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>logger</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="blond.llrf.cavity_feedback.SPSCavityFeedback.track">
<code class="sig-name descname">track</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSCavityFeedback.track" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="blond.llrf.cavity_feedback.SPSCavityFeedback.track_init">
<code class="sig-name descname">track_init</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">debug</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSCavityFeedback.track_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Tracking of the SPSCavityFeedback without beam.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback">
<em class="property">class </em><code class="sig-prename descclassname">blond.llrf.cavity_feedback.</code><code class="sig-name descname">SPSOneTurnFeedback</code><span class="sig-paren">(</span><em class="sig-param">RFStation</em>, <em class="sig-param">Beam</em>, <em class="sig-param">Profile</em>, <em class="sig-param">n_sections</em>, <em class="sig-param">n_cavities=2</em>, <em class="sig-param">V_part=0.4444444444444444</em>, <em class="sig-param">G_ff=1</em>, <em class="sig-param">G_llrf=10</em>, <em class="sig-param">G_tx=0.5</em>, <em class="sig-param">a_comb=0.9375</em>, <em class="sig-param">Commissioning=&lt;blond.llrf.cavity_feedback.CavityFeedbackCommissioning object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Voltage feedback around a travelling wave cavity with given amount of
sections. The quantities of the LLRF system cover one turn with a coarse
resolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RFStation</strong> (<em>class</em>) – An RFStation type class</p></li>
<li><p><strong>Beam</strong> (<em>class</em>) – A Beam type class</p></li>
<li><p><strong>Profile</strong> (<em>class</em>) – Beam profile object</p></li>
<li><p><strong>n_sections</strong> (<em>int</em>) – Number of sections in the cavities</p></li>
<li><p><strong>n_cavities</strong> (<em>int</em>) – Number of cavities of the same type</p></li>
<li><p><strong>V_part</strong> (<em>float</em>) – Voltage partition for the given n_cavities; in range (0,1)</p></li>
<li><p><strong>G_ff</strong> (<em>float</em>) – FF gain [1]; default is 1</p></li>
<li><p><strong>G_llrf</strong> (<em>float</em>) – LLRF gain [1]; default is 10</p></li>
<li><p><strong>G_tx</strong> (<em>float</em>) – Transmitter gain [A/V]; default is <span class="math notranslate nohighlight">\((50 \Omega)^{-1}\)</span></p></li>
<li><p><strong>open_loop</strong> (<em>int</em><em>(</em><em>bool</em><em>)</em>) – Open (0) or closed (1) feedback loop; default is 1</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.TWC">
<code class="sig-name descname">TWC</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.TWC" title="Permalink to this definition">¶</a></dt>
<dd><p>A TravellingWaveCavity type class</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>class</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.counter">
<code class="sig-name descname">counter</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.counter" title="Permalink to this definition">¶</a></dt>
<dd><p>Counter of the current time step</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.omega_c">
<code class="sig-name descname">omega_c</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.omega_c" title="Permalink to this definition">¶</a></dt>
<dd><p>Carrier revolution frequency [1/s] at the current time step</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.omega_r">
<code class="sig-name descname">omega_r</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.omega_r" title="Permalink to this definition">¶</a></dt>
<dd><p>Resonant revolution frequency [1/s] of the travelling wave cavities</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>const float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.n_coarse">
<code class="sig-name descname">n_coarse</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.n_coarse" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of bins for the coarse grid (equals harmonic number)</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_gen">
<code class="sig-name descname">V_gen</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator voltage [V] of the present turn in (I,Q) coordinates</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_gen_prev">
<code class="sig-name descname">V_gen_prev</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_gen_prev" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator voltage [V] of the previous turn in (I,Q) coordinates</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_fine_ind_beam">
<code class="sig-name descname">V_fine_ind_beam</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_fine_ind_beam" title="Permalink to this definition">¶</a></dt>
<dd><p>Beam-induced voltage [V] in (I,Q) coordinates on the fine grid
used for tracking the beam</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_coarse_ind_beam">
<code class="sig-name descname">V_coarse_ind_beam</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_coarse_ind_beam" title="Permalink to this definition">¶</a></dt>
<dd><p>Beam-induced voltage [V] in (I,Q) coordinates on the coarse grid used
tracking the LLRF</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_coarse_ind_gen">
<code class="sig-name descname">V_coarse_ind_gen</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_coarse_ind_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator-induced voltage [V] in (I,Q) coordinates on the coarse grid
used tracking the LLRF</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_coarse_tot">
<code class="sig-name descname">V_coarse_tot</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_coarse_tot" title="Permalink to this definition">¶</a></dt>
<dd><p>Cavity voltage [V] at present turn in (I,Q) coordinates which is used
for tracking the LLRF</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_fine_tot">
<code class="sig-name descname">V_fine_tot</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_fine_tot" title="Permalink to this definition">¶</a></dt>
<dd><p>Cavity voltage [V] at present turn in (I,Q) coordinates which is used
for tracking the beam</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.a_comb">
<code class="sig-name descname">a_comb</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.a_comb" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursion constant of the comb filter; <span class="math notranslate nohighlight">\(a_{\mathsf{comb}}=15/16\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.n_mov_av">
<code class="sig-name descname">n_mov_av</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.n_mov_av" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of points for moving average modelling cavity response;
<span class="math notranslate nohighlight">\(n_{\mathsf{mov.av.}} = \frac{f_r}{f_{\mathsf{bw,cav}}}\)</span>, where
<span class="math notranslate nohighlight">\(f_r\)</span> is the cavity resonant frequency of TWC_4 and TWC_5</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>const int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.logger">
<code class="sig-name descname">logger</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>Logger of the present class</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>logger</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.beam_induced_voltage">
<code class="sig-name descname">beam_induced_voltage</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">lpf</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.beam_induced_voltage" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the beam-induced voltage</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>lpf</strong> (<em>bool</em>) – Apply low-pass filter for beam current calculation;
default is False</p>
</dd>
</dl>
<dl class="py attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.I_beam_coarse">
<code class="sig-name descname">I_beam_coarse</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.I_beam_coarse" title="Permalink to this definition">¶</a></dt>
<dd><p>RF component of the beam charge [C] at the present time step,
calculated in coarse grid</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.I_beam_fine">
<code class="sig-name descname">I_beam_fine</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.I_beam_fine" title="Permalink to this definition">¶</a></dt>
<dd><p>RF component of the beam charge [C] at the present time step,
calculated in fine grid</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="id0">
<code class="sig-name descname">V_coarse_ind_beam</code><a class="headerlink" href="#id0" title="Permalink to this definition">¶</a></dt>
<dd><p>Induced voltage [V] from beam-cavity interaction on the
coarse grid</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="id1">
<code class="sig-name descname">V_fine_ind_beam</code><a class="headerlink" href="#id1" title="Permalink to this definition">¶</a></dt>
<dd><p>Induced voltage [V] from beam-cavity interaction on the fine
grid</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.call_conv">
<code class="sig-name descname">call_conv</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">signal</span></em>, <em class="sig-param"><span class="n">kernel</span></em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.call_conv" title="Permalink to this definition">¶</a></dt>
<dd><p>Routine to call optimised C++ convolution</p>
</dd></dl>

<dl class="py method">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.generator_induced_voltage">
<code class="sig-name descname">generator_induced_voltage</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.generator_induced_voltage" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the generator-induced voltage. The transmitter model is
a simple linear gain [C/V] converting voltage to charge.</p>
<div class="math notranslate nohighlight">
\[I = G_{\mathsf{tx}}\,\frac{V}{R_{\mathsf{gen}}} \, ,\]</div>
<p>where <span class="math notranslate nohighlight">\(R_{\mathsf{gen}}\)</span> is the generator resistance,
<code class="xref py py-attr docutils literal notranslate"><span class="pre">llrf.impulse_response.TravellingWaveCavity.R_gen</span></code></p>
<dl class="py attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.I_gen">
<code class="sig-name descname">I_gen</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.I_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>RF component of the generator charge [C] at the present time step</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="id2">
<code class="sig-name descname">V_coarse_ind_gen</code><a class="headerlink" href="#id2" title="Permalink to this definition">¶</a></dt>
<dd><p>Induced voltage [V] from generator-cavity interaction</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.induced_voltage">
<code class="sig-name descname">induced_voltage</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.induced_voltage" title="Permalink to this definition">¶</a></dt>
<dd><p>Generation of beam- or generator-induced voltage from the
beam or
generator current, at a given carrier frequency and turn. The
induced
voltage <span class="math notranslate nohighlight">\(V(t)\)</span> is calculated from the impulse response matrix
<span class="math notranslate nohighlight">\(h(t)\)</span> as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left( \begin{matrix} V_I(t) \\
V_Q(t) \end{matrix} \right)
= \left( \begin{matrix} h_s(t) &amp; - h_c(t) \\
h_c(t) &amp; h_s(t) \end{matrix} \right)
* \left( \begin{matrix} I_I(t) \\
I_Q(t) \end{matrix} \right) \, ,\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(*\)</span> denotes convolution,
<span class="math notranslate nohighlight">\(h(t)*x(t) = \int d\tau h(\tau)x(t-\tau)\)</span>. If the carrier
frequency is close to the cavity resonant frequency, <span class="math notranslate nohighlight">\(h_c
= 0\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">See also</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">llrf.impulse_response.TravellingWaveCavity</span></code></p>
</dd>
</dl>
<p>The impulse response is made to be the same length as the beam
profile.</p>
</dd></dl>

<dl class="py method">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.llrf_model">
<code class="sig-name descname">llrf_model</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.llrf_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Models the LLRF part of the OTFB.</p>
<dl class="py attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_set">
<code class="sig-name descname">V_set</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Voltage set point [V] in (I,Q); <span class="math notranslate nohighlight">\(V_{\mathsf{set}}\)</span>, amplitude
proportional to voltage partition</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.dV_gen">
<code class="sig-name descname">dV_gen</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.dV_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator voltage [V] in (I,Q);
<span class="math notranslate nohighlight">\(dV_{\mathsf{gen}} = V_{\mathsf{set}} - V_{\mathsf{tot}}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.matr_conv">
<code class="sig-name descname">matr_conv</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">I</span></em>, <em class="sig-param"><span class="n">h</span></em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.matr_conv" title="Permalink to this definition">¶</a></dt>
<dd><p>Convolution of beam current with impulse response; uses a complete
matrix with off-diagonal elements.</p>
</dd></dl>

<dl class="py method">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.track">
<code class="sig-name descname">track</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.track" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn-by-turn tracking method.</p>
</dd></dl>

<dl class="py method">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.track_no_beam">
<code class="sig-name descname">track_no_beam</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.track_no_beam" title="Permalink to this definition">¶</a></dt>
<dd><p>Initial tracking method, before injecting beam.</p>
</dd></dl>

<dl class="py method">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.update_variables">
<code class="sig-name descname">update_variables</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.update_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Update counter and frequency-dependent variables in a given turn</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-blond.llrf.impulse_response">
<span id="impulse-response-module"></span><h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">impulse_response</span></code> Module<a class="headerlink" href="#module-blond.llrf.impulse_response" title="Permalink to this headline">¶</a></h2>
<p><strong>Filters and methods for control loops</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Authors</dt>
<dd class="field-odd"><p><strong>Helga Timko</strong></p>
</dd>
</dl>
<dl class="py class">
<dt id="blond.llrf.impulse_response.SPS3Section200MHzTWC">
<em class="property">class </em><code class="sig-prename descclassname">blond.llrf.impulse_response.</code><code class="sig-name descname">SPS3Section200MHzTWC</code><a class="headerlink" href="#blond.llrf.impulse_response.SPS3Section200MHzTWC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#blond.llrf.impulse_response.TravellingWaveCavity" title="blond.llrf.impulse_response.TravellingWaveCavity"><code class="xref py py-class docutils literal notranslate"><span class="pre">blond.llrf.impulse_response.TravellingWaveCavity</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt id="blond.llrf.impulse_response.SPS4Section200MHzTWC">
<em class="property">class </em><code class="sig-prename descclassname">blond.llrf.impulse_response.</code><code class="sig-name descname">SPS4Section200MHzTWC</code><a class="headerlink" href="#blond.llrf.impulse_response.SPS4Section200MHzTWC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#blond.llrf.impulse_response.TravellingWaveCavity" title="blond.llrf.impulse_response.TravellingWaveCavity"><code class="xref py py-class docutils literal notranslate"><span class="pre">blond.llrf.impulse_response.TravellingWaveCavity</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt id="blond.llrf.impulse_response.SPS5Section200MHzTWC">
<em class="property">class </em><code class="sig-prename descclassname">blond.llrf.impulse_response.</code><code class="sig-name descname">SPS5Section200MHzTWC</code><a class="headerlink" href="#blond.llrf.impulse_response.SPS5Section200MHzTWC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#blond.llrf.impulse_response.TravellingWaveCavity" title="blond.llrf.impulse_response.TravellingWaveCavity"><code class="xref py py-class docutils literal notranslate"><span class="pre">blond.llrf.impulse_response.TravellingWaveCavity</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity">
<em class="property">class </em><code class="sig-prename descclassname">blond.llrf.impulse_response.</code><code class="sig-name descname">TravellingWaveCavity</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">l_cell</span></em>, <em class="sig-param"><span class="n">N_cells</span></em>, <em class="sig-param"><span class="n">rho</span></em>, <em class="sig-param"><span class="n">v_g</span></em>, <em class="sig-param"><span class="n">omega_r</span></em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Impulse responses of a travelling wave cavity. The induced voltage
<span class="math notranslate nohighlight">\(V(t)\)</span> from the impulse response <span class="math notranslate nohighlight">\(h(t)\)</span> and the I,Q (cavity or
generator) current <span class="math notranslate nohighlight">\(I(t)\)</span> can be written in matrix form,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left( \begin{matrix} V_I(t) \\
V_Q(t) \end{matrix} \right)
= \left( \begin{matrix} h_s(t) &amp; - h_c(t) \\
h_c(t) &amp; h_s(t) \end{matrix} \right)
* \left( \begin{matrix} I_I(t) \\
I_Q(t) \end{matrix} \right) \, ,\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(*\)</span> denotes convolution,
<span class="math notranslate nohighlight">\(h(t)*x(t) = \int d\tau h(\tau)x(t-\tau)\)</span>.</p>
<p>For the <strong>cavity-to-beam induced voltage</strong>, we define</p>
<div class="math notranslate nohighlight">
\[R_b \equiv \frac{\rho l^2}{8} \,\]</div>
<p>where <span class="math notranslate nohighlight">\(\rho\)</span> is the series impedance, <span class="math notranslate nohighlight">\(l\)</span> the accelerating
length, <span class="math notranslate nohighlight">\(\tau\)</span> the filling time. The cavity-to-beam wake is</p>
<div class="math notranslate nohighlight">
\[W_b(t) = \frac{4 R_b}{\tau} \mathsf{tri}\left(\frac{t}{\tau}\right)
 \cos(\omega_r t)\]</div>
<p>and the impulse response components are</p>
<div class="math notranslate nohighlight">
\[\begin{split}h_{s,b}(t) &amp;= \frac{2 R_b}{\tau} \mathsf{tri}\left(\frac{t}{\tau}\right)
 \cos((\omega_c - \omega_r)t) \, , \\
h_{c,b}(t) &amp;= \frac{2 R_b}{\tau} \mathsf{tri}\left(\frac{t}{\tau}\right)
\sin((\omega_c - \omega_r)t) \, ,\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathsf{tri}(x)\)</span> is the triangular function, <span class="math notranslate nohighlight">\(\omega_r\)</span>
is the central revolution frequency of the cavity, and <span class="math notranslate nohighlight">\(\omega_c\)</span> is
the carrier revolution frequency of the I,Q demodulated current signal. On
the carrier frequency, <span class="math notranslate nohighlight">\(\omega_c = \omega_r\)</span>,</p>
<div class="math notranslate nohighlight">
\[\begin{split}h_{s,b}(t) &amp;= \frac{2 R_b}{\tau} \mathsf{tri}\left(\frac{t}{\tau}\right) \\
h_{c,b}(t) &amp;= 0 \, .\end{split}\]</div>
<p>For the <strong>cavity-to-generator induced voltage</strong>, we define</p>
<div class="math notranslate nohighlight">
\[R_g \equiv l \sqrt{\frac{\rho Z_0}{2}} \,\]</div>
<p>where <span class="math notranslate nohighlight">\(Z_0\)</span> is the shunt impedance when measuring the generator
current; assumed to be 50 <span class="math notranslate nohighlight">\(\Omega\)</span>. The cavity-to-generator wake is</p>
<div class="math notranslate nohighlight">
\[W_g(t) = \frac{2 R_g}{\tau} \mathsf{rect}\left(\frac{t}{\tau}\right)
\cos(\omega_r t)\]</div>
<p>and the impulse response components are</p>
<div class="math notranslate nohighlight">
\[\begin{split}h_{s,g}(t) &amp;= \frac{R_g}{\tau} \mathsf{rect}\left(\frac{t}{\tau}\right)
\cos((\omega_c - \omega_r)t) \, , \\
h_{c,g}(t) &amp;= \frac{R_g}{\tau} \mathsf{rect}\left(\frac{t}{\tau}\right)
\sin((\omega_c - \omega_r)t) \, ,\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathsf{rect}(x)\)</span> is the rectangular function. On the carrier
frequency, <span class="math notranslate nohighlight">\(\omega_c = \omega_r\)</span>,</p>
<div class="math notranslate nohighlight">
\[\begin{split}h_{s,g}(t) &amp;= \frac{R_g}{\tau} \mathsf{rect}\left(\frac{t}{\tau}\right) \\
h_{c,g}(t) &amp;= 0 \, .\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>l_cell</strong> (<em>float</em>) – Cavity cell length [m]</p></li>
<li><p><strong>N_cells</strong> (<em>int</em>) – Number of accelerating (interacting) cells in a cavity</p></li>
<li><p><strong>rho</strong> (<em>float</em>) – Series impedance [Ohms/m^2] of the cavity</p></li>
<li><p><strong>v_g</strong> (<em>float</em>) – Group velocity [c] in units of the speed of light</p></li>
<li><p><strong>omega_r</strong> (<em>flaot</em>) – Central (resonance) revolution frequency [1/s] of the cavity</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.Z_0">
<code class="sig-name descname">Z_0</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.Z_0" title="Permalink to this definition">¶</a></dt>
<dd><p>Shunt impedance of generator current measurement; assumed to be 50 Ohms</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.R_beam">
<code class="sig-name descname">R_beam</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.R_beam" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math notranslate nohighlight">\(R_b\)</span> [Omega] as defined above</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.R_gen">
<code class="sig-name descname">R_gen</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.R_gen" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math notranslate nohighlight">\(R_g\)</span> [Omega] as defined above</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.l_cav">
<code class="sig-name descname">l_cav</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.l_cav" title="Permalink to this definition">¶</a></dt>
<dd><p>Length [m] of the interaction region</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.tau">
<code class="sig-name descname">tau</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.tau" title="Permalink to this definition">¶</a></dt>
<dd><p>Cavity filling time [s]</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.compute_wakes">
<code class="sig-name descname">compute_wakes</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">time</span></em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.compute_wakes" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the wake fields towards the beam and generator on the
central cavity frequency.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_beam</strong> (<em>float</em>) – Time array of the beam to act on</p></li>
<li><p><strong>time_gen</strong> (<em>float</em>) – Time array of the generator to act on</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.W_beam">
<code class="sig-name descname">W_beam</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.W_beam" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math notranslate nohighlight">\(W_b(t)\)</span> [Omega/s] as defined above</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.W_gen">
<code class="sig-name descname">W_gen</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.W_gen" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math notranslate nohighlight">\(W_g(t)\)</span> [Omega/s] as defined above</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float array</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.impulse_response_beam">
<code class="sig-name descname">impulse_response_beam</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">omega_c</span></em>, <em class="sig-param"><span class="n">time_fine</span></em>, <em class="sig-param"><span class="n">time_coarse</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.impulse_response_beam" title="Permalink to this definition">¶</a></dt>
<dd><p>Impulse response from the cavity towards the beam. For a signal
that is I,Q demodulated at a given carrier
frequency <span class="math notranslate nohighlight">\(\omega_c\)</span>. The formulae assume that the carrier
frequency is be close to the central frequency
<span class="math notranslate nohighlight">\(\omega_c/\omega_r \ll 1\)</span> and that the signal is low-pass
filtered (i.e.high-frequency components can be neglected).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>omega_c</strong> (<em>float</em>) – Carrier revolution frequency [1/s]</p></li>
<li><p><strong>time_fine</strong> (<em>float</em>) – Time array of the beam profile to act on</p></li>
<li><p><strong>time_coarse</strong> (<em>float</em>) – Time array of the LLRF to act on; default is None</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.d_omega">
<code class="sig-name descname">d_omega</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.d_omega" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math notranslate nohighlight">\(\omega_c - \omega_r\)</span> [1/s]</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.t_beam">
<code class="sig-name descname">t_beam</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.t_beam" title="Permalink to this definition">¶</a></dt>
<dd><p>time array for beam wake and impulse response; starts from zero</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.h_beam">
<code class="sig-name descname">h_beam</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.h_beam" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math notranslate nohighlight">\(h_{s,b}(t) + i*h_{c,b}(t)\)</span> [Omega/s] as defined above</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.h_beam_coarse">
<code class="sig-name descname">h_beam_coarse</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.h_beam_coarse" title="Permalink to this definition">¶</a></dt>
<dd><p>Impulse response evaluated on the coarse grid</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.impulse_response_gen">
<code class="sig-name descname">impulse_response_gen</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">omega_c</span></em>, <em class="sig-param"><span class="n">time_coarse</span></em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.impulse_response_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Impulse response from the cavity towards the
generator. For a signal that is I,Q demodulated at a given carrier
frequency <span class="math notranslate nohighlight">\(\omega_c\)</span>. The formulae assume that the carrier
frequency is be close to the central frequency
<span class="math notranslate nohighlight">\(\omega_c/\omega_r \ll 1\)</span> and that the signal is low-pass
filtered (i.e.high-frequency components can be neglected).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>omega_c</strong> (<em>float</em>) – Carrier revolution frequency [1/s]</p></li>
<li><p><strong>time_coarse</strong> (<em>float</em>) – Time array of the LLRF to act on</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="id3">
<code class="sig-name descname">d_omega</code><a class="headerlink" href="#id3" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math notranslate nohighlight">\(\omega_c - \omega_r\)</span> [1/s]</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.t_gen">
<code class="sig-name descname">t_gen</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.t_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>time array for generator wake and impulse response; starts from
<span class="math notranslate nohighlight">\(- \tau/2\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float array</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.h_gen">
<code class="sig-name descname">h_gen</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.h_gen" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math notranslate nohighlight">\(h_{s,b}(t) + i*h_{c,b}(t)\)</span> [Omega/s] as defined above</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="blond.llrf.impulse_response.rectangle">
<code class="sig-prename descclassname">blond.llrf.impulse_response.</code><code class="sig-name descname">rectangle</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">tau</span></em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.impulse_response.rectangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Rectangular function of time</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathsf{rect} \left( \frac{t}{\tau} \right) =
\begin{cases}
    1 \, , \, t \in (-\tau/2, \tau/2) \\
    0.5 \, , \, t = \pm \tau/2 \\
    0 \, , \, \textsf{otherwise}
\end{cases}\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> (<em>float array</em>) – Time array</p></li>
<li><p><strong>tau</strong> (<em>float</em>) – Time window of rectangular function</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Rectangular function for given time array</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="blond.llrf.impulse_response.triangle">
<code class="sig-prename descclassname">blond.llrf.impulse_response.</code><code class="sig-name descname">triangle</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">tau</span></em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.impulse_response.triangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Triangular function of time</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathsf{tri} \left( \frac{t}{\tau} \right) =
\begin{cases}
    1 - \frac{t}{\tau}\, , \, t \in (0, \tau) \\
    0.5 \, , \, t = 0 \\
    0 \, , \, \textsf{otherwise}
\end{cases}\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> (<em>float array</em>) – Time array</p></li>
<li><p><strong>tau</strong> (<em>float</em>) – Time window of rectangular function</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Triangular function for given time array</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float array</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-blond.llrf.rf_modulation">
<span id="rf-modulation-module"></span><h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">rf_modulation</span></code> Module<a class="headerlink" href="#module-blond.llrf.rf_modulation" title="Permalink to this headline">¶</a></h2>
<p><strong>Methods to generate RF phase modulation from given frequency, amplitude
and offset functions</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Authors</dt>
<dd class="field-odd"><p><strong>Simon Albright</strong></p>
</dd>
</dl>
<dl class="py class">
<dt id="blond.llrf.rf_modulation.PhaseModulation">
<em class="property">class </em><code class="sig-prename descclassname">blond.llrf.rf_modulation.</code><code class="sig-name descname">PhaseModulation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">timebase</span></em>, <em class="sig-param"><span class="n">frequency</span></em>, <em class="sig-param"><span class="n">amplitude</span></em>, <em class="sig-param"><span class="n">offset</span></em>, <em class="sig-param"><span class="n">harmonic</span></em>, <em class="sig-param"><span class="n">multiplier</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">modulate_frequency</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.rf_modulation.PhaseModulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt id="blond.llrf.rf_modulation.PhaseModulation.calc_delta_omega">
<code class="sig-name descname">calc_delta_omega</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">omegaProg</span></em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.rf_modulation.PhaseModulation.calc_delta_omega" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="blond.llrf.rf_modulation.PhaseModulation.calc_modulation">
<code class="sig-name descname">calc_modulation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.rf_modulation.PhaseModulation.calc_modulation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="blond.llrf.rf_modulation.PhaseModulation.extend_to_n_rf">
<code class="sig-name descname">extend_to_n_rf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">harmonics</span></em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.rf_modulation.PhaseModulation.extend_to_n_rf" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="llrf-rf-noise-module">
<h2>llrf.rf_noise Module<a class="headerlink" href="#llrf-rf-noise-module" title="Permalink to this headline">¶</a></h2>
<p><strong>Methods to generate RF phase noise from noise spectrum and feedback noise
amplitude as a function of bunch length</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Authors</dt>
<dd class="field-odd"><p><strong>Helga Timko</strong></p>
</dd>
</dl>
<div class="section" id="rf-phase-noise-generation">
<h3>RF phase noise generation<a class="headerlink" href="#rf-phase-noise-generation" title="Permalink to this headline">¶</a></h3>
<dl class="py class">
<dt id="blond.llrf.rf_modulation.llrf.rf_noise.PhaseNoise">
<em class="property">class </em><code class="sig-prename descclassname">llrf.rf_noise.</code><code class="sig-name descname">PhaseNoise</code><span class="sig-paren">(</span><em class="sig-param">object).__init__(frequency_array</em>, <em class="sig-param">real_part_of_spectrum</em>, <em class="sig-param">seed1=None</em>, <em class="sig-param">seed2=None</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.rf_modulation.llrf.rf_noise.PhaseNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains the spectrum of RF phase noise and the actual phase noise randomly
generated from it. Generation done via mixing with white noise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frequency_array</strong> (<em>numpy.array</em>) – input frequency range</p></li>
<li><p><strong>real_part_of_spectrum</strong> (<em>numpy.array</em>) – input spectrum, real part only,
same length as <code class="docutils literal notranslate"><span class="pre">frequency_array</span></code></p></li>
<li><p><strong>seed1</strong> (<em>int</em>) – seed for random number generator</p></li>
<li><p><strong>seed2</strong> (<em>int</em>) – seed for random number generator</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The spectrum has to be input as double-sided spectrum, in units
of [<span class="math notranslate nohighlight">\(\text{rad}^2/\text{Hz}\)</span>].</p>
</div>
<p>Both hermitian to real and complex to complex FFTs are available. Use seeds
to fix a certain random number sequence; with <code class="docutils literal notranslate"><span class="pre">seed=None</span></code> a random sequence
will be initialized.</p>
<dl class="py method">
<dt id="blond.llrf.rf_modulation.llrf.rf_noise.PhaseNoise.spectrum_to_phase_noise">
<code class="sig-name descname">spectrum_to_phase_noise</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">transform</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.rf_modulation.llrf.rf_noise.PhaseNoise.spectrum_to_phase_noise" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms a noise spectrum to phase noise data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>transform</strong> (<em>choice</em>) – FFT transform kind</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>time and phase noise arrays</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">transform=None</span></code> or <code class="docutils literal notranslate"><span class="pre">'r'</span></code> to transform hermitian
spectrum to real phase. In this case, input only the positive part of
the double-sided spectrum. Use <code class="docutils literal notranslate"><span class="pre">transform='c'</span></code> to transform complex
spectrum to complex phase. In this case, input first the zero and
positive frequency components, then the decreasingly negative frequency
components of the double-sided spectrum. Returns only the real part of
the phase noise. E.g. the following two ways of usage are equivalent:</p>
<a class="reference internal image-reference" href="../_images/RF_noise.png"><img alt="../_images/RF_noise.png" class="align-center" src="../_images/RF_noise.png" style="width: 1000px; height: 250px;" /></a>
</div>
<p><strong>The transformation in steps</strong></p>
<p><strong>Step 1:</strong> Set the resolution in time domain. To transform a hermitian
spectrum to real phase noise,</p>
<div class="math notranslate nohighlight">
\[n_t = 2 (n_f - 1) \text{\,\,and\,\,} \Delta t = 1/(2 f_{\text{max}}) ,\]</div>
<p>and to transform a complex spectrum to complex phase noise,</p>
<div class="math notranslate nohighlight">
\[n_t = n_f \text{\,\,and\,\,} \Delta t = 1/f_{\text{max}} ,\]</div>
<p>where <code class="docutils literal notranslate"><span class="pre">fmax</span></code> is the maximum frequency in the input in both cases.</p>
<p><strong>Step 2:</strong> Generate white (carrier) noise in time domain</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}w_k(t) = \cos(2 \pi r_k^{(1)}) \sqrt{-2 \ln(r_k^{(2)})} \text{\,\,\,case `r'},\\w_k(t) = \exp(2 \pi i r_k^{(1)}) \sqrt{-2 \ln(r_k^{(2)})} \text{\,\,\,case `c'},\end{aligned}\end{align} \]</div>
<p><strong>Step 3:</strong> Transform the generated white noise to frequency domain</p>
<div class="math notranslate nohighlight">
\[W_l(f) = \sum_{k=1}^N w_k(t) e^{-2 \pi i \frac{k l}{N}} .\]</div>
<p><strong>Step 4:</strong> In frequency domain, colour the white noise with the desired
noise probability density (unit: radians). The noise probability density
derived from the double-sided spectrum is</p>
<div class="math notranslate nohighlight">
\[s_l(f) = \sqrt{A S_l^{\text{DB}} f_{\text{max}}} ,\]</div>
<p>where <span class="math notranslate nohighlight">\(A=2\)</span> for <code class="docutils literal notranslate"><span class="pre">transform</span> <span class="pre">=</span> <span class="pre">'r'</span></code> and <span class="math notranslate nohighlight">\(A=1\)</span> for
<code class="docutils literal notranslate"><span class="pre">transform</span> <span class="pre">=</span> <span class="pre">'c'</span></code>. The coloured noise is obtained by multiplication in
frequency domain</p>
<div class="math notranslate nohighlight">
\[\Phi_l(f) = s_l(f) W_l(f) .\]</div>
<p><strong>Step 5:</strong> Transform back the coloured spectrum to time domain to obtain
the final phase shift array (we use only the real part).</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="lhc-type-phase-noise-generation">
<h3>LHC-type phase noise generation<a class="headerlink" href="#lhc-type-phase-noise-generation" title="Permalink to this headline">¶</a></h3>
<dl class="py class">
<dt id="blond.llrf.rf_modulation.llrf.rf_noise.LHCFlatSpectrum">
<em class="property">class </em><code class="sig-prename descclassname">llrf.rf_noise.</code><code class="sig-name descname">LHCFlatSpectrum</code><span class="sig-paren">(</span><em class="sig-param">object).__init__(GeneralParameters</em>, <em class="sig-param">RFSectionParameters</em>, <em class="sig-param">time_points</em>, <em class="sig-param">corr_time = 10000</em>, <em class="sig-param">fmin = 0.8571</em>, <em class="sig-param">fmax = 1.1</em>, <em class="sig-param">initial_amplitude = 1.e-6</em>, <em class="sig-param">seed1 = 1234</em>, <em class="sig-param">seed2 = 7564</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.rf_modulation.llrf.rf_noise.LHCFlatSpectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates LHC-type phase noise from a band-limited spectrum. Input frequency
band using <code class="docutils literal notranslate"><span class="pre">fmin</span></code> and <code class="docutils literal notranslate"><span class="pre">fmax</span></code> w.r.t. the synchrotron frequency. Input
double-sided spectrum amplitude [<span class="math notranslate nohighlight">\(\text{rad}^2/\text{Hz}\)</span>] using
<code class="docutils literal notranslate"><span class="pre">initial_amplitude</span></code>. Fix seeds to obtain reproducible phase noise. Select
<code class="docutils literal notranslate"><span class="pre">time_points</span></code> suitably to resolve the spectrum in frequency domain. After
<code class="docutils literal notranslate"><span class="pre">corr_time</span></code> turns, the seed is changed (reproducibly) to cut numerical
correlated sequences of the random number generator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>GeneralParameters</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">input_parameters.general_parameters.GeneralParameters</span></code></p></li>
<li><p><strong>RFSectionParameters</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">input_parameters.rf_parameters.RFSectionParameters</span></code></p></li>
<li><p><strong>time_points</strong> (<em>int</em>) – number of phase noise points of a sample in time
domain</p></li>
<li><p><strong>corr_time</strong> (<em>int</em>) – number of turns after which seed is changed</p></li>
<li><p><strong>fmin</strong> (<em>double</em>) – spectrum lower limit in units of synchrotron frequency</p></li>
<li><p><strong>fmax</strong> (<em>double</em>) – spectrum upper limit in units of synchrotron frequency</p></li>
<li><p><strong>initial_amplitude</strong> (<em>double</em>) – initial double sided spectral density
[<span class="math notranslate nohighlight">\(\text{rad}^2/\text{Hz}\)</span>]</p></li>
<li><p><strong>seed1</strong> (<em>int</em>) – seed for random number generator</p></li>
<li><p><strong>seed2</strong> (<em>int</em>) – seed for random number generator</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code class="docutils literal notranslate"><span class="pre">time_points</span></code> should be chosen large enough to resolve the
desired frequency step <span class="math notranslate nohighlight">\(\Delta f =\)</span>
<code class="xref py py-attr docutils literal notranslate"><span class="pre">GeneralParameters.f_rev</span></code>/<code class="xref py py-attr docutils literal notranslate"><span class="pre">LHCFlatSpectrum.time_points</span></code>
in frequency domain.</p>
</div>
<dl class="py method">
<dt id="blond.llrf.rf_modulation.llrf.rf_noise.LHCFlatSpectrum.generate">
<code class="sig-name descname">generate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.rf_modulation.llrf.rf_noise.LHCFlatSpectrum.generate" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates LHC-type phase noise array (length:
<code class="xref py py-attr docutils literal notranslate"><span class="pre">GeneralParameters.n_turns</span></code> + 1). Stored in the variable
<code class="xref py py-attr docutils literal notranslate"><span class="pre">LHCFlatSpectrum.dphi</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="bunch-length-based-feedback-on-noise-amplitude">
<h3>Bunch-length based feedback on noise amplitude<a class="headerlink" href="#bunch-length-based-feedback-on-noise-amplitude" title="Permalink to this headline">¶</a></h3>
<dl class="py class">
<dt id="blond.llrf.rf_modulation.llrf.rf_noise.LHCNoiseFB">
<em class="property">class </em><code class="sig-prename descclassname">llrf.rf_noise.</code><code class="sig-name descname">LHCNoiseFB</code><span class="sig-paren">(</span><em class="sig-param">object).__init__(bl_target</em>, <em class="sig-param">gain = 1.5</em>, <em class="sig-param">factor = 0.8</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.rf_modulation.llrf.rf_noise.LHCNoiseFB" title="Permalink to this definition">¶</a></dt>
<dd><p>Feedback on phase noise amplitude for LHC controlled longitudinal emittance
blow-up using noise injection through cavity controller or phase loop.
The feedback compares the FWHM bunch length of the bunch to a target value
and scales the phase noise to keep the targeted value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bl_target</strong> – Targeted 4-sigma-equivalent FWHM bunch length [ns]</p></li>
<li><p><strong>gain</strong> – feedback gain [1/ns]</p></li>
<li><p><strong>factor</strong> – feedback recursion scaling factor [1]</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Note that the FWMH bunch length is scaled by
<span class="math notranslate nohighlight">\(\sqrt{2/\ln{2}}\)</span> in order to obtain a 4-sigma equivalent value.</p>
</div>
<dl class="py method">
<dt id="blond.llrf.rf_modulation.llrf.rf_noise.LHCNoiseFB.FB">
<code class="sig-name descname">FB</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">RFSectionParameters</span></em>, <em class="sig-param"><span class="n">Beam</span></em>, <em class="sig-param"><span class="n">PhaseNoise</span></em>, <em class="sig-param"><span class="n">Slices</span></em>, <em class="sig-param"><span class="n">CC</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.rf_modulation.llrf.rf_noise.LHCNoiseFB.FB" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the bunch-length based feedback scaling factor as a function
of measured FWHM bunch length. For phase noise injected through the
cavity RF voltage, the feedback scaling can be directly applied on the
<code class="xref py py-attr docutils literal notranslate"><span class="pre">RFSectionParameters.phi_noise</span></code> variable by setting
<code class="docutils literal notranslate"><span class="pre">CC</span> <span class="pre">=</span> <span class="pre">True</span></code>. For phase noise injected through the <code class="xref py py-class docutils literal notranslate"><span class="pre">PhaseLoop</span></code>
class, the correction can be applied inside the phase loop, via passing
<code class="xref py py-class docutils literal notranslate"><span class="pre">LHCNoiseFB</span></code> as an argument in <code class="xref py py-class docutils literal notranslate"><span class="pre">PhaseLoop</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RFSectionParameters</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">input_parameters.rf_parameters.RFSectionParameters</span></code></p></li>
<li><p><strong>Beam</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">beams.beams.Beam</span></code></p></li>
<li><p><strong>PhaseNoise</strong> – phase-noise type class,
<a class="reference internal" href="#blond.llrf.rf_modulation.llrf.rf_noise.PhaseNoise" title="blond.llrf.rf_modulation.llrf.rf_noise.PhaseNoise"><code class="xref py py-class docutils literal notranslate"><span class="pre">llrf.rf_noise.PhaseNoise</span></code></a> or
<a class="reference internal" href="#blond.llrf.rf_modulation.llrf.rf_noise.LHCFlatSpectrum" title="blond.llrf.rf_modulation.llrf.rf_noise.LHCFlatSpectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">llrf.rf_noise.LHCFlatSpectrum</span></code></a></p></li>
<li><p><strong>Slices</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">beams.slices.Slices</span></code></p></li>
<li><p><strong>CC</strong> (<em>bool</em>) – cavity controller option</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="blond.llrf.rf_modulation.fwhm">
<em class="property">classmethod </em><code class="sig-prename descclassname">blond.llrf.rf_modulation.</code><code class="sig-name descname">fwhm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Slices</span></em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.rf_modulation.fwhm" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast FWHM bunch length calculation with slice width precision.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>Slices</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">beams.slices.Slices</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>4-sigma-equivalent FWHM bunch length [ns]</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-blond.llrf.signal_processing">
<span id="signal-processing-module"></span><h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal_processing</span></code> Module<a class="headerlink" href="#module-blond.llrf.signal_processing" title="Permalink to this headline">¶</a></h2>
<p><strong>Filters and methods for control loops</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Authors</dt>
<dd class="field-odd"><p><strong>Helga Timko</strong></p>
</dd>
</dl>
<dl class="py function">
<dt id="blond.llrf.signal_processing.cartesian_to_polar">
<code class="sig-prename descclassname">blond.llrf.signal_processing.</code><code class="sig-name descname">cartesian_to_polar</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">IQ_vector</span></em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.signal_processing.cartesian_to_polar" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert data from Cartesian (I,Q) to polar coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>IQ_vector</strong> (<em>complex array</em>) – Signal with in-phase and quadrature (I,Q) components</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>float array</em> – Amplitude of signal</p></li>
<li><p><em>float array</em> – Phase of signal</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="blond.llrf.signal_processing.comb_filter">
<code class="sig-prename descclassname">blond.llrf.signal_processing.</code><code class="sig-name descname">comb_filter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">a</span></em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.signal_processing.comb_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Feedback comb filter.</p>
</dd></dl>

<dl class="py function">
<dt id="blond.llrf.signal_processing.feedforward_filter">
<code class="sig-prename descclassname">blond.llrf.signal_processing.</code><code class="sig-name descname">feedforward_filter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">TWC</span><span class="p">:</span> <span class="n"><a class="reference internal" href="#blond.llrf.impulse_response.TravellingWaveCavity" title="blond.llrf.impulse_response.TravellingWaveCavity">blond.llrf.impulse_response.TravellingWaveCavity</a></span></em>, <em class="sig-param"><span class="n">T_s</span></em>, <em class="sig-param"><span class="n">debug</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">taps</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">opt_output</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.signal_processing.feedforward_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to design n-tap FIR filter for SPS TravellingWaveCavity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>TWC</strong> (<a class="reference internal" href="#blond.llrf.impulse_response.TravellingWaveCavity" title="blond.llrf.impulse_response.TravellingWaveCavity"><em>TravellingWaveCavity</em></a>) – TravellingWaveCavity type class</p></li>
<li><p><strong>T_s</strong> (<em>float</em>) – Sampling time [s]</p></li>
<li><p><strong>debug</strong> (<em>bool</em>) – When True, activates printouts and plots; default is False</p></li>
<li><p><strong>taps</strong> (<em>int</em>) – User-defined number of taps; default is None and number of taps is
calculated from the filling time</p></li>
<li><p><strong>opt_output</strong> (<em>bool</em>) – When True, activates optional output; default is False</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>float array</em> – FIR filter coefficients</p></li>
<li><p><em>int</em> – Optional output: Number of FIR filter taps</p></li>
<li><p><em>int</em> – Optional output: Filling time in samples</p></li>
<li><p><em>int</em> – Optional output: Fitting time in samples, n_filling, n_fit</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="blond.llrf.signal_processing.low_pass_filter">
<code class="sig-prename descclassname">blond.llrf.signal_processing.</code><code class="sig-name descname">low_pass_filter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">signal</span></em>, <em class="sig-param"><span class="n">cutoff_frequency</span><span class="o">=</span><span class="default_value">0.5</span></em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.signal_processing.low_pass_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Low-pass filter based on Butterworth 5th order digital filter from
scipy,
<a class="reference external" href="http://docs.scipy.org">http://docs.scipy.org</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>float array</em>) – Signal to be filtered</p></li>
<li><p><strong>cutoff_frequency</strong> (<em>float</em>) – Cutoff frequency [1] corresponding to a 3 dB gain drop, relative to the
Nyquist frequency of 1; default is 0.5</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Low-pass filtered signal</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="blond.llrf.signal_processing.modulator">
<code class="sig-prename descclassname">blond.llrf.signal_processing.</code><code class="sig-name descname">modulator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">signal</span></em>, <em class="sig-param"><span class="n">omega_i</span></em>, <em class="sig-param"><span class="n">omega_f</span></em>, <em class="sig-param"><span class="n">T_sampling</span></em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.signal_processing.modulator" title="Permalink to this definition">¶</a></dt>
<dd><p>Demodulate a signal from initial frequency to final frequency. The two
frequencies should be close.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>float array</em>) – Signal to be demodulated</p></li>
<li><p><strong>omega_i</strong> (<em>float</em>) – Initial revolution frequency [1/s] of signal (before demodulation)</p></li>
<li><p><strong>omega_f</strong> (<em>float</em>) – Final revolution frequency [1/s] of signal (after demodulation)</p></li>
<li><p><strong>T_sampling</strong> (<em>float</em>) – Sampling period (temporal bin size) [s] of the signal</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Demodulated signal at f_final</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="blond.llrf.signal_processing.moving_average">
<code class="sig-prename descclassname">blond.llrf.signal_processing.</code><code class="sig-name descname">moving_average</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">N</span></em>, <em class="sig-param"><span class="n">x_prev</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.signal_processing.moving_average" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to calculate the moving average (or running mean) of the input
data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>float array</em>) – Data to be smoothed</p></li>
<li><p><strong>N</strong> (<em>int</em>) – Window size in points</p></li>
<li><p><strong>x_prev</strong> (<em>float array</em>) – Data to pad with in front</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>Smoothed data array of size</dt><dd><ul class="simple">
<li><p>len(x) - N + 1, if x_prev = None</p></li>
<li><p>len(x) + len(x_prev) - N + 1, if x_prev given</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="blond.llrf.signal_processing.polar_to_cartesian">
<code class="sig-prename descclassname">blond.llrf.signal_processing.</code><code class="sig-name descname">polar_to_cartesian</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">amplitude</span></em>, <em class="sig-param"><span class="n">phase</span></em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.signal_processing.polar_to_cartesian" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert data from polar to cartesian (I,Q) coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>amplitude</strong> (<em>float array</em>) – Amplitude of signal</p></li>
<li><p><strong>phase</strong> (<em>float array</em>) – Phase of signal</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Signal with in-phase and quadrature (I,Q) components</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="blond.llrf.signal_processing.rf_beam_current">
<code class="sig-prename descclassname">blond.llrf.signal_processing.</code><code class="sig-name descname">rf_beam_current</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Profile</span></em>, <em class="sig-param"><span class="n">omega_c</span></em>, <em class="sig-param"><span class="n">T_rev</span></em>, <em class="sig-param"><span class="n">lpf</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">downsample</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.signal_processing.rf_beam_current" title="Permalink to this definition">¶</a></dt>
<dd><p>Function calculating the beam charge at the (RF) frequency, slice by
slice. The charge distribution [C] of the beam is determined from the beam
profile <span class="math notranslate nohighlight">\(\lambda_i\)</span>, the particle charge <span class="math notranslate nohighlight">\(q_p\)</span> and the real vs.
macro-particle ratio <span class="math notranslate nohighlight">\(N_{\mathsf{real}}/N_{\mathsf{macro}}\)</span></p>
<div class="math notranslate nohighlight">
\[Q_i = \frac{N_{\mathsf{real}}}{N_{\mathsf{macro}}} q_p \lambda_i\]</div>
<p>The total charge [C] in the beam is then</p>
<div class="math notranslate nohighlight">
\[Q_{\mathsf{tot}} = \sum_i{Q_i}\]</div>
<p>The DC beam current [A] is the total number of charges per turn <span class="math notranslate nohighlight">\(T_0\)</span></p>
<div class="math notranslate nohighlight">
\[I_{\mathsf{DC}} = \frac{Q_{\mathsf{tot}}}{T_0}\]</div>
<p>The RF beam charge distribution [C] at a revolution frequency
<span class="math notranslate nohighlight">\(\omega_c\)</span> is the complex quantity</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left( \begin{matrix} I_{rf,i} \\
Q_{rf,i} \end{matrix} \right)
= 2 Q_i \left( \begin{matrix} \cos(\omega_c t_i) \\
\sin(\omega_c t_i)\end{matrix} \right) \, ,\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(t_i\)</span> are the time coordinates of the beam profile. After de-
modulation, a low-pass filter at 20 MHz is applied.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Profile</strong> (<em>class</em>) – A Profile type class</p></li>
<li><p><strong>omega_c</strong> (<em>float</em>) – Revolution frequency [1/s] at which the current should be calculated</p></li>
<li><p><strong>T_rev</strong> (<em>float</em>) – Revolution period [s] of the machine</p></li>
<li><p><strong>lpf</strong> (<em>bool</em>) – Apply low-pass filter; default is True</p></li>
<li><p><strong>downsample</strong> (<em>dict</em>) – Dictionary containing float value for ‘Ts’ sampling time and int value
for ‘points’. Will downsample the RF beam charge onto a coarse time
grid with ‘Ts’ sampling time and ‘points’ points.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>complex array</em> – RF beam charge array [C] at ‘frequency’ omega_c, with the sampling time
of the Profile object. To obtain current, divide by the sampling time</p></li>
<li><p><em>(complex array)</em> – If time_coarse is specified, returns also the RF beam charge array [C]
on the coarse time grid</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="monitors.html" class="btn btn-neutral float-right" title="monitors Package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="input_parameters.html" class="btn btn-neutral" title="input_parameters Package" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/language_data.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
   

</body>
</html>