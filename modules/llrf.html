

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>llrf Package &mdash; BLonD 1.1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="BLonD 1.1 documentation" href="../index.html"/>
        <link rel="next" title="monitors Package" href="monitors.html"/>
        <link rel="prev" title="input_parameters Package" href="input_parameters.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> BLonD
          

          
          </a>

          
            
            
              <div class="version">
                1.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="equations_of_motion.html">Equations of Motion</a><ul>
<li class="toctree-l2"><a class="reference internal" href="equations_of_motion.html#definitions">Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="equations_of_motion.html#energy-kick">Energy kick</a></li>
<li class="toctree-l2"><a class="reference internal" href="equations_of_motion.html#arrival-time-drift">Arrival time drift</a></li>
<li class="toctree-l2"><a class="reference internal" href="equations_of_motion.html#the-synchronous-particle">The synchronous particle</a></li>
<li class="toctree-l2"><a class="reference internal" href="equations_of_motion.html#small-amplitude-oscillations">Small-amplitude oscillations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="equations_of_motion.html#tracking-utilities">Tracking utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="equations_of_motion.html#hamiltonian">Hamiltonian</a></li>
<li class="toctree-l2"><a class="reference internal" href="equations_of_motion.html#separatrix">Separatrix</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="beam.html">beam Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="beam.html#module-blond.beam.beam"><code class="docutils literal notranslate"><span class="pre">beam</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="beam.html#module-blond.beam.coasting_beam"><code class="docutils literal notranslate"><span class="pre">coasting_beam</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="beam.html#module-blond.beam.distributions"><code class="docutils literal notranslate"><span class="pre">distributions</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="beam.html#module-blond.beam.distributions_multibunch"><code class="docutils literal notranslate"><span class="pre">distributions_multibunch</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="beam.html#module-blond.beam.profile"><code class="docutils literal notranslate"><span class="pre">profile</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="beam.html#module-blond.beam.sparse_slices"><code class="docutils literal notranslate"><span class="pre">sparse_slices</span></code> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="impedances.html">impedances Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="impedances.html#module-blond.impedances.impedance"><code class="docutils literal notranslate"><span class="pre">impedance</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="impedances.html#module-blond.impedances.impedance_sources"><code class="docutils literal notranslate"><span class="pre">impedance_sources</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="impedances.html#module-blond.impedances.induced_voltage_analytical"><code class="docutils literal notranslate"><span class="pre">induced_voltage_analytical</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="impedances.html#module-blond.impedances.music"><code class="docutils literal notranslate"><span class="pre">music</span></code> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="input_parameters.html">input_parameters Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="input_parameters.html#module-blond.input_parameters.rf_parameters"><code class="docutils literal notranslate"><span class="pre">rf_parameters</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="input_parameters.html#module-blond.input_parameters.ring"><code class="docutils literal notranslate"><span class="pre">ring</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="input_parameters.html#module-blond.input_parameters.ring_options"><code class="docutils literal notranslate"><span class="pre">ring_options</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="input_parameters.html#module-blond.input_parameters.rf_parameters_options"><code class="docutils literal notranslate"><span class="pre">rf_parameters_options</span></code> Module</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">llrf Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-blond.llrf.notch_filter"><code class="docutils literal notranslate"><span class="pre">notch_filter</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#llrf-beam-feedback-module">llrf.beam_feedback Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#machine-dependent-beam-phase-loop">Machine-dependent Beam Phase Loop</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-blond.llrf.cavity_feedback"><code class="docutils literal notranslate"><span class="pre">cavity_feedback</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-blond.llrf.impulse_response"><code class="docutils literal notranslate"><span class="pre">impulse_response</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-blond.llrf.rf_modulation"><code class="docutils literal notranslate"><span class="pre">rf_modulation</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#llrf-rf-noise-module">llrf.rf_noise Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#rf-phase-noise-generation">RF phase noise generation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#lhc-type-phase-noise-generation">LHC-type phase noise generation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bunch-length-based-feedback-on-noise-amplitude">Bunch-length based feedback on noise amplitude</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-blond.llrf.signal_processing"><code class="docutils literal notranslate"><span class="pre">signal_processing</span></code> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="monitors.html">monitors Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="monitors.html#module-blond.monitors.monitors"><code class="docutils literal notranslate"><span class="pre">monitors</span></code> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="plots.html">plots Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="plots.html#module-blond.plots.plot"><code class="docutils literal notranslate"><span class="pre">plot</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="plots.html#module-blond.plots.plot_beams"><code class="docutils literal notranslate"><span class="pre">plot_beams</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="plots.html#module-blond.plots.plot_impedance"><code class="docutils literal notranslate"><span class="pre">plot_impedance</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="plots.html#module-blond.plots.plot_llrf"><code class="docutils literal notranslate"><span class="pre">plot_llrf</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="plots.html#module-blond.plots.plot_parameters"><code class="docutils literal notranslate"><span class="pre">plot_parameters</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="plots.html#module-blond.plots.plot_slices"><code class="docutils literal notranslate"><span class="pre">plot_slices</span></code> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="synchrotron_radiation.html">synchrotron_radiation Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="synchrotron_radiation.html#module-blond.synchrotron_radiation.synchrotron_radiation"><code class="docutils literal notranslate"><span class="pre">synchrotron_radiation</span></code> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="toolbox.html">toolbox Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="toolbox.html#module-blond.toolbox.action"><code class="docutils literal notranslate"><span class="pre">action</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="toolbox.html#module-blond.toolbox.convolution"><code class="docutils literal notranslate"><span class="pre">convolution</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="toolbox.html#module-blond.toolbox.diffusion"><code class="docutils literal notranslate"><span class="pre">diffusion</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="toolbox.html#module-blond.toolbox.next_regular"><code class="docutils literal notranslate"><span class="pre">next_regular</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="toolbox.html#module-blond.toolbox.parameter_scaling"><code class="docutils literal notranslate"><span class="pre">parameter_scaling</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="toolbox.html#module-blond.toolbox.tomoscope"><code class="docutils literal notranslate"><span class="pre">tomoscope</span></code> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="trackers.html">trackers Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="trackers.html#module-blond.trackers.tracker"><code class="docutils literal notranslate"><span class="pre">tracker</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trackers.html#module-blond.trackers.utilities"><code class="docutils literal notranslate"><span class="pre">utilities</span></code> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="compile.html">compile Module</a><ul>
<li class="toctree-l2"><a class="reference internal" href="compile.html#id1"><code class="docutils literal notranslate"><span class="pre">compile</span></code> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="utils.html">utils Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="utils.html#module-blond.utils.bmath"><code class="docutils literal notranslate"><span class="pre">bmath</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="utils.html#module-blond.utils.bphysics_wrap"><code class="docutils literal notranslate"><span class="pre">bphysics_wrap</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="utils.html#module-blond.utils.butils_wrap"><code class="docutils literal notranslate"><span class="pre">butils_wrap</span></code> Module</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>
    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">BLonD</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>llrf Package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/modules/llrf.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="llrf-package">
<h1>llrf Package<a class="headerlink" href="#llrf-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-blond.llrf.notch_filter">
<span id="notch-filter-module"></span><h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">notch_filter</span></code> Module<a class="headerlink" href="#module-blond.llrf.notch_filter" title="Permalink to this headline">¶</a></h2>
<p><strong>Method to apply a notch filter to a specified impedance source</strong></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><strong>Danilo Quartullo</strong></td>
</tr>
</tbody>
</table>
<dl class="function">
<dt id="blond.llrf.notch_filter.impedance_notches">
<code class="descclassname">blond.llrf.notch_filter.</code><code class="descname">impedance_notches</code><span class="sig-paren">(</span><em>f_rev</em>, <em>frequencies</em>, <em>imp_source</em>, <em>list_harmonics</em>, <em>list_width_depth</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.notch_filter.impedance_notches" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="llrf-beam-feedback-module">
<h2>llrf.beam_feedback Module<a class="headerlink" href="#llrf-beam-feedback-module" title="Permalink to this headline">¶</a></h2>
<p><strong>Various beam phase loops (PL) with optional synchronisation (SL), frequency
(FL), or radial loops (RL) for the CERN machines</strong></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><strong>Helga Timko</strong></td>
</tr>
</tbody>
</table>
<div class="section" id="machine-dependent-beam-phase-loop">
<h3>Machine-dependent Beam Phase Loop<a class="headerlink" href="#machine-dependent-beam-phase-loop" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop">
<em class="property">class </em><code class="descclassname">llrf.phase_loop.</code><code class="descname">PhaseLoop</code><span class="sig-paren">(</span><em>object).__init__(GeneralParameters</em>, <em>RFSectionParameters</em>, <em>Slices</em>, <em>gain</em>, <em>gain2 = 0</em>, <em>machine = 'LHC'</em>, <em>period = None</em>, <em>window_coefficient = 0</em>, <em>coefficients = None</em>, <em>PhaseNoise = None</em>, <em>LHCNoiseFB = None</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop" title="Permalink to this definition">¶</a></dt>
<dd><p>One-turn PL for different machines with different hardware. The beam phase is
calculated as the convolution of the beam profile with the RF wave of the
main harmonic system (corresponding to a band-pass filter). The PL acts
directly on the RF frequency and phase of all harmonics.</p>
<p>Some machine-dependent features:</p>
<ul class="simple">
<li>PSB: use <code class="docutils literal notranslate"><span class="pre">sampling_frequency</span></code> for a PL that is active only at certain
turns.</li>
<li>SPS: use <code class="docutils literal notranslate"><span class="pre">window</span> <span class="pre">coefficient</span></code> to sample beam phase over a suitable
amount of bunches (<code class="docutils literal notranslate"><span class="pre">window_coefficient</span> <span class="pre">=</span> <span class="pre">0</span></code> results in single-bunch
acquisition as in the LHC)</li>
<li>LHC_F: PL with optional FL (use <code class="docutils literal notranslate"><span class="pre">gain2</span></code> to activate)</li>
<li>LHC: PL with optional SL (use <code class="docutils literal notranslate"><span class="pre">gain2</span></code> to activate; note that gain is
frequency dependent)</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>GeneralParameters</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">input_parameters.general_parameters.GeneralParameters</span></code></li>
<li><strong>RFSectionParameters</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">input_parameters.rf_parameters.RFSectionParameters</span></code></li>
<li><strong>Slices</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">beams.slices.Slices</span></code></li>
<li><strong>gain</strong> (<em>double</em>) – phase loop gain [1/ns], typically <span class="math notranslate nohighlight">\(\sim 1/(10 T_0)\)</span></li>
<li><strong>gain2</strong> (<em>double</em>) – FL gain [turns] or SL gain [1/ns], depending on machine;
typically ~10 times weaker than PL</li>
<li><strong>machine</strong> (<em>str</em>) – machine name, determines PL choice</li>
<li><strong>period</strong> (<em>double</em>) – optional for PSB: period of PL being active</li>
<li><strong>window_coefficient</strong> (<em>double</em>) – window coefficient for band-pass filter
determining beam phase; use 0 for single-bunch acquisition</li>
<li><strong>coefficients</strong> (<em>array</em>) – optional for PSB: PL transfer function
coefficients</li>
<li><strong>PhaseNoise</strong> – optional: phase-noise type class for noise injection
through the PL,
<code class="xref py py-class docutils literal notranslate"><span class="pre">llrf.rf_noise.PhaseNoise</span></code> or
<code class="xref py py-class docutils literal notranslate"><span class="pre">llrf.rf_noise.LHCFlatSpectrum</span></code></li>
<li><strong>LHCNoiseFB</strong> – optional: bunch-length feedback class for phase noise
<code class="xref py py-class docutils literal notranslate"><span class="pre">llrf.rf_noise.LHCNoiseFB</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop.track">
<code class="descname">track</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop.track" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the PL correction on main RF frequency depending on machine.
Updates the RF phase and frequency of the next turn for all RF systems.</p>
<p>Let <span class="math notranslate nohighlight">\(\Delta \omega_{\mathsf{TOT}}\)</span> be the total frequency correction
(calculation depends on the machine, see below). The RF frequency of a
given RF system <span class="math notranslate nohighlight">\(i\)</span> is then shifted by</p>
<div class="math notranslate nohighlight">
\[\Delta \omega_{\mathsf{rf},i} = \frac{h_i}{h_0} \Delta
\omega_{\mathsf{TOT}} ,\]</div>
<p>with a corresponding RF phase shift of</p>
<div class="math notranslate nohighlight">
\[\Delta \varphi_{\mathsf{rf},i} = 2 \pi h_i
\frac{\omega_{\mathsf{rf},i}}{\Omega_{\mathsf{rf},i}} ,\]</div>
<p>where <span class="math notranslate nohighlight">\(\Omega_{\mathsf{rf},i} = h_i \omega_0\)</span> is the design
frequency and <span class="math notranslate nohighlight">\(\omega_{\mathsf{rf},i}\)</span> the actual RF frequency
applied.</p>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop.precalculate_time">
<code class="descname">precalculate_time</code><span class="sig-paren">(</span><em>GeneralParameters</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop.precalculate_time" title="Permalink to this definition">¶</a></dt>
<dd><p>For PSB, where the PL acts only with a given periodicity, pre-calculate on
which turns to act.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>GeneralParameters</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">input_parameters.general_parameters.GeneralParameters</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop.beam_phase">
<code class="descname">beam_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop.beam_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Beam phase measured at the main RF frequency and phase. The beam is
convolved with the window function of the band-pass filter of the machine.
The coefficients of sine and cosine components determine the beam phase,
projected to the range -Pi/2 to 3/2 Pi.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">that this beam phase is already determined w.r.t. the
instantaneous RF phase.</p>
</div>
<p>The band-pass filter modelled assumes a window function of the form</p>
<div class="math notranslate nohighlight">
\[W(t) = e^{-\alpha t}
\cos(\omega_{\mathsf{rf}} t - \varphi_{\mathsf{rf}}) ,\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha\)</span> is the <code class="docutils literal notranslate"><span class="pre">window_coefficient</span></code> that determines how
many bunches are taken into account.</p>
<p>The convolution of <span class="math notranslate nohighlight">\(W(t)\)</span> with the bunch profile <span class="math notranslate nohighlight">\(\lambda(t)\)</span>
results in two components,</p>
<div class="math notranslate nohighlight">
\[f(t) = \int_{\lambda_{\mathsf{min}}}^{\lambda_{\mathsf{max}}}
{e^{-\alpha (t-\tau)} \cos(\omega_{\mathsf{rf}} (t-\tau) -
\varphi_{\mathsf{rf}}) \lambda(\tau) d\tau}
= e^{-\alpha t} \cos(\omega_{\mathsf{rf}} t)
\int_{\lambda_{\mathsf{min}}}^{\lambda_{\mathsf{max}}}
{e^{\alpha \tau} \cos(\omega_{\mathsf{rf}} \tau +
\varphi_{\mathsf{rf}}) \lambda(\tau) d\tau}
+ e^{-\alpha t} \sin(\omega_{\mathsf{rf}} t)
\int_{\lambda_{\mathsf{min}}}^{\lambda_{\mathsf{max}}}
{e^{\alpha \tau} \sin(\omega_{\mathsf{rf}} \tau +
\varphi_{\mathsf{rf}}) \lambda(\tau) d\tau} .\]</div>
<p>The beam phase is determined from the coefficients of the sine and cosine
components, i.e.</p>
<div class="math notranslate nohighlight">
\[\varphi_b \equiv \arctan \left(
\frac{\int_{\lambda_{\mathsf{min}}}^{\lambda_{\mathsf{max}}}
{e^{\alpha \tau} \sin(\omega_{\mathsf{rf}} \tau +
\varphi_{\mathsf{rf}}) \lambda(\tau) d\tau}}
{\int_{\lambda_{\mathsf{min}}}^{\lambda_{\mathsf{max}}}
{e^{\alpha \tau} \cos(\omega_{\mathsf{rf}} \tau +
\varphi_{\mathsf{rf}}) \lambda(\tau) d\tau}} \right) .\]</div>
<p>This projects the beam phase to the interval
<span class="math notranslate nohighlight">\(\left( -\frac{\pi}{2} , \frac{\pi}{2}\right)\)</span>, however, the RF
phase is defined on the interval
<span class="math notranslate nohighlight">\(\left( -\frac{\pi}{2} , \frac{3 \pi}{2}\right)\)</span>. In order to get a
correct measurement of the beam phase, we thus add <span class="math notranslate nohighlight">\(\pi\)</span> if the
cosine coefficient is negative (meaning normally the beam energy is above
transition).</p>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop.phase_difference">
<code class="descname">phase_difference</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop.phase_difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Phase difference between beam and RF phase of the main RF system.
Optional: add RF phase noise through dphi directly.</p>
<p>As the actual RF phase is taken into account already in the beam phase
calculation, only the synchronous phase needs to be substracted and thus
the phase difference seen by the PL becomes</p>
<div class="math notranslate nohighlight">
\[\Delta \varphi_{\mathsf{PL}} = \varphi_b - \varphi_s .\]</div>
<p>If phase noise is injected through the PL, it is added directly as an
offset to this measurement, optionally with the feedback scaling factor
<span class="math notranslate nohighlight">\(x\)</span>.</p>
<div class="math notranslate nohighlight">
\[\Delta \varphi_{\mathsf{PL}} = \varphi_b - \varphi_s
+ (x) \phi_N .\]</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">LHC_F():</code></dt>
<dd><p>Calculates the RF frequency correction <span class="math notranslate nohighlight">\(\Delta \omega_{\mathsf{PL}}\)</span>
from the phase difference between beam and RF
<span class="math notranslate nohighlight">\(\Delta \varphi_{\mathsf{PL}}\)</span> for the LHC. The transfer function is</p>
<div class="math notranslate nohighlight">
\[\Delta \omega_{\mathsf{PL}} = - g_{\mathsf{PL}}
\Delta\varphi_{\mathsf{PL}} ,\]</div>
<p>Using ‘gain2’, the frequency loop can be activated in addition to remove
long-term frequency drifts:</p>
<div class="math notranslate nohighlight">
\[\Delta \omega_{\mathsf{FL}} = - g_{\mathsf{FL}}
(\omega_{\mathsf{rf}} - h \omega_{0}) .\]</div>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop.LHC">
<code class="descname">LHC</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.notch_filter.llrf.phase_loop.PhaseLoop.LHC" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the RF frequency correction <span class="math notranslate nohighlight">\(\Delta \omega_{\mathsf{PL}}\)</span>
from the phase difference between beam and RF
<span class="math notranslate nohighlight">\(\Delta \varphi_{\mathsf{PL}}\)</span> for the LHC. The transfer function is</p>
<div class="math notranslate nohighlight">
\[\Delta \omega_{\mathsf{PL}} = - g_{\mathsf{PL}}
\Delta \varphi_{\mathsf{PL}} ,\]</div>
<p>Using ‘gain2’, a synchro loop can be activated in addition to remove
long-term frequency and phase drifts:</p>
<div class="math notranslate nohighlight">
\[\Delta \omega_{\mathsf{SL}} = - g_{\mathsf{SL}}
(y + a \, \Delta \varphi_{\mathsf{rf}}) ,\]</div>
<p>where <span class="math notranslate nohighlight">\(\Delta \varphi_{\mathsf{rf}}\)</span> is the accumulated RF phase
deviation from the design value and <span class="math notranslate nohighlight">\(y\)</span> is is obtained through the
recursion (<span class="math notranslate nohighlight">\(y_0 = 0\)</span>)</p>
<div class="math notranslate nohighlight">
\[y_{n+1} = (1 - \tau) y_n + (1 - a) \tau
\Delta \varphi_{\mathsf{rf}} .\]</div>
<p>The variables <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(\tau\)</span> are being defined through the
(single-harmonic, central) synchrotron frequency <span class="math notranslate nohighlight">\(f_s\)</span> and the
corresponding synchrotron tune <span class="math notranslate nohighlight">\(Q_s\)</span> as</p>
<div class="math notranslate nohighlight">
\[a (f_s) \equiv 5.25 - \frac{f_s}{\pi 40~\text{Hz}} ,\]</div>
<div class="math notranslate nohighlight">
\[\tau(f_s) \equiv 2 \pi Q_s \sqrt{ \frac{a}{1 +
\frac{g_{\mathsf{PL}}}{g_{\mathsf{SL}}} \sqrt{\frac{1 + 1/a}{1 + a}} }} .\]</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">PSB():</code></dt>
<dd><p>Phase loop:</p>
<p>The transfer function of the system is</p>
<div class="math notranslate nohighlight">
\[H(z) = g \frac{b_{0}+b_{1} z^{-1}}{1 +a_{1} z^{-1}}\]</div>
<p>where g is the gain and <span class="math notranslate nohighlight">\(b_{0} = 0.99901903\)</span>, <span class="math notranslate nohighlight">\(b_{1} = -0.99901003\)</span>,
<span class="math notranslate nohighlight">\(a_{1} = -0.99803799\)</span>.</p>
<p>Let <span class="math notranslate nohighlight">\(\Delta \phi_{PL}\)</span> and <span class="math notranslate nohighlight">\(\Delta \omega_{PL}\)</span> be the
phase difference and the phase loop correction on the frequency
respectively; since these two quantities are the input and output of our
system, then from the transfer function we
have in time domain (see <a class="reference external" href="https://en.wikipedia.org/wiki/Z-transform">https://en.wikipedia.org/wiki/Z-transform</a>):</p>
<div class="math notranslate nohighlight">
\[\Delta \omega_{PL}^{n+1} = - a_{1} \Delta \omega_{PL}^{n} +
g(b_{0} \Delta \phi_{PL}^{n+1} + b_{1} \Delta \phi_{PL}^{n})\]</div>
<p>In fact the phase and radial loops act every 10 <span class="math notranslate nohighlight">\(\mu s\)</span> and as a
consequence <span class="math notranslate nohighlight">\(\Delta \phi_{PL}\)</span> is an average on all the values
between two trigger times.</p>
<p>Radial loop:</p>
<p>We estimate
the difference of the radii of the actual trajectory and the desired trajectory
using one of the four known differential relations with <span class="math notranslate nohighlight">\(\Delta B = 0\)</span>:</p>
<div class="math notranslate nohighlight">
\[\frac{\Delta R}{R} = \frac{\Delta \omega_{RF}}{\omega_{RF}}
\frac{\gamma^2}{\gamma_{T}^2-\gamma^2}\]</div>
<p>In reality the error <span class="math notranslate nohighlight">\(\Delta R\)</span> is filtered with a PI (Proportional-
Integrator) corrector. This means that</p>
<div class="math notranslate nohighlight">
\[\Delta \omega_{RL}^{n+1} = K_{P} \left(\frac{\Delta R}{R}\right)^{n}
+ K_{I} \int_0^n \! \frac{\Delta R}{R} (t) \, \mathrm{d}t.\]</div>
<p>Writing the same equation for <span class="math notranslate nohighlight">\(\Delta \omega_{RL}^{n}\)</span> and
subtracting side by side we have</p>
<div class="math notranslate nohighlight">
\[\Delta \omega_{RL}^{n+1} = \Delta \omega_{RL}^{n} +
K_{P} \left[ \left(\frac{\Delta R}{R}\right)^{n} -
\left(\frac{\Delta R}{R}\right)^{n-1} \right] + K_{I}^{'}
\left(\frac{\Delta R}{R}\right)^{n}\]</div>
<p>here <span class="math notranslate nohighlight">\(K_{I}^{'} = K_{I} 10 \mu s\)</span> and we approximated the integral
with a simple product.</p>
<p>The total correction is then</p>
<div class="math notranslate nohighlight">
\[\Delta \omega_{RF}^{n+1} = \Delta \omega_{PL}^{n+1} + \Delta \omega_{RL}^{n+1}\]</div>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-blond.llrf.cavity_feedback">
<span id="cavity-feedback-module"></span><h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">cavity_feedback</span></code> Module<a class="headerlink" href="#module-blond.llrf.cavity_feedback" title="Permalink to this headline">¶</a></h2>
<p><strong>Various cavity loops for the CERN machines</strong></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><strong>Helga Timko</strong></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="blond.llrf.cavity_feedback.CavityFeedbackCommissioning">
<em class="property">class </em><code class="descclassname">blond.llrf.cavity_feedback.</code><code class="descname">CavityFeedbackCommissioning</code><span class="sig-paren">(</span><em>debug=False</em>, <em>open_loop=False</em>, <em>open_FB=False</em>, <em>open_drive=False</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.CavityFeedbackCommissioning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

<dl class="class">
<dt id="blond.llrf.cavity_feedback.SPSCavityFeedback">
<em class="property">class </em><code class="descclassname">blond.llrf.cavity_feedback.</code><code class="descname">SPSCavityFeedback</code><span class="sig-paren">(</span><em>RFStation</em>, <em>Beam</em>, <em>Profile</em>, <em>G_llrf=10</em>, <em>G_tx=0.5</em>, <em>a_comb=0.9375</em>, <em>turns=1000</em>, <em>Commissioning=&lt;blond.llrf.cavity_feedback.CavityFeedbackCommissioning object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSCavityFeedback" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class determining the turn-by-turn total RF voltage and phase correction
originating from the individual cavity feedbacks. Assumes two 4-section and
two 5-section travelling wave cavities and a voltage partition proportional
to the number of sections.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>RFStation</strong> (<em>class</em>) – An RFStation type class</li>
<li><strong>Beam</strong> (<em>class</em>) – A Beam type class</li>
<li><strong>Profile</strong> (<em>class</em>) – A Profile type class</li>
<li><strong>G_llrf</strong> (<em>float</em><em> or </em><em>list</em>) – LLRF Gain [1]; if passed as a float, both 4- and 5-section cavities
have the same G_llrf; if passed as a list, the first and second
elements correspond to the G_llrf of the 4- and 5-section cavity
feedback; default is 10</li>
<li><strong>G_tx</strong> (<em>float</em><em> or </em><em>list</em>) – Transmitter gain [1] of the cavity feedback; convention same as G_llrf;
default is 0.5</li>
<li><strong>open_loop</strong> (<em>int</em><em>(</em><em>bool</em><em>)</em>) – Open (0) or closed (1) feedback loop; default is 1</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSCavityFeedback.OTFB_4">
<code class="descname">OTFB_4</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSCavityFeedback.OTFB_4" title="Permalink to this definition">¶</a></dt>
<dd><p>An SPSOneTurnFeedback type class</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">class</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSCavityFeedback.OTFB_5">
<code class="descname">OTFB_5</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSCavityFeedback.OTFB_5" title="Permalink to this definition">¶</a></dt>
<dd><p>An SPSOneTurnFeedback type class</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">class</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSCavityFeedback.V_sum">
<code class="descname">V_sum</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSCavityFeedback.V_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Vector sum of RF voltage from all the cavities</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">complex array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSCavityFeedback.V_corr">
<code class="descname">V_corr</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSCavityFeedback.V_corr" title="Permalink to this definition">¶</a></dt>
<dd><p>RF voltage correction array to be applied in the tracker</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">float array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSCavityFeedback.phi_corr">
<code class="descname">phi_corr</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSCavityFeedback.phi_corr" title="Permalink to this definition">¶</a></dt>
<dd><p>RF phase correction array to be applied in the tracker</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">float array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSCavityFeedback.logger">
<code class="descname">logger</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSCavityFeedback.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>Logger of the present class</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">logger</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.SPSCavityFeedback.track">
<code class="descname">track</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSCavityFeedback.track" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.SPSCavityFeedback.track_init">
<code class="descname">track_init</code><span class="sig-paren">(</span><em>debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSCavityFeedback.track_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Tracking of the SPSCavityFeedback without beam.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback">
<em class="property">class </em><code class="descclassname">blond.llrf.cavity_feedback.</code><code class="descname">SPSOneTurnFeedback</code><span class="sig-paren">(</span><em>RFStation</em>, <em>Beam</em>, <em>Profile_</em>, <em>n_sections</em>, <em>n_cavities=2</em>, <em>V_part=0.4444444444444444</em>, <em>G_llrf=10</em>, <em>G_tx=0.5</em>, <em>a_comb=0.9375</em>, <em>Commissioning=&lt;blond.llrf.cavity_feedback.CavityFeedbackCommissioning object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Voltage feedback around a travelling wave cavity with given amount of
sections. The quantities of the LLRF system cover one turn with a coarse
resolution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>RFStation</strong> (<em>class</em>) – An RFStation type class</li>
<li><strong>Beam</strong> (<em>class</em>) – A Beam type class</li>
<li><strong>Profile</strong> (<em>class</em>) – Beam profile object</li>
<li><strong>n_sections</strong> (<em>int</em>) – Number of sections in the cavities</li>
<li><strong>n_cavities</strong> (<em>int</em>) – Number of cavities of the same type</li>
<li><strong>V_part</strong> (<em>float</em>) – Voltage partition for the given n_cavities; in range (0,1)</li>
<li><strong>G_tx</strong> (<em>float</em>) – Transmitter gain [A/V]; default is <span class="math notranslate nohighlight">\((50 \Omega)^{-1}\)</span></li>
<li><strong>open_loop</strong> (<em>int</em><em>(</em><em>bool</em><em>)</em>) – Open (0) or closed (1) feedback loop; default is 1</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.TWC">
<code class="descname">TWC</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.TWC" title="Permalink to this definition">¶</a></dt>
<dd><p>A TravellingWaveCavity type class</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">class</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.counter">
<code class="descname">counter</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.counter" title="Permalink to this definition">¶</a></dt>
<dd><p>Counter of the current time step</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.omega_c">
<code class="descname">omega_c</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.omega_c" title="Permalink to this definition">¶</a></dt>
<dd><p>Carrier revolution frequency [1/s] at the current time step</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.omega_r">
<code class="descname">omega_r</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.omega_r" title="Permalink to this definition">¶</a></dt>
<dd><p>Resonant revolution frequency [1/s] of the travelling wave cavities</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">const float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.n_coarse">
<code class="descname">n_coarse</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.n_coarse" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of bins for the coarse grid (equals harmonic number)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_gen">
<code class="descname">V_gen</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator voltage [V] of the present turn in (I,Q) coordinates</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">complex array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_gen_prev">
<code class="descname">V_gen_prev</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_gen_prev" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator voltage [V] of the previous turn in (I,Q) coordinates</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">complex array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_fine_ind_beam">
<code class="descname">V_fine_ind_beam</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_fine_ind_beam" title="Permalink to this definition">¶</a></dt>
<dd><p>Beam-induced voltage [V] in (I,Q) coordinates on the fine grid
used for tracking the beam</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">complex array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_coarse_ind_beam">
<code class="descname">V_coarse_ind_beam</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_coarse_ind_beam" title="Permalink to this definition">¶</a></dt>
<dd><p>Beam-induced voltage [V] in (I,Q) coordinates on the coarse grid used
tracking the LLRF</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">complex array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_coarse_ind_gen">
<code class="descname">V_coarse_ind_gen</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_coarse_ind_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator-induced voltage [V] in (I,Q) coordinates on the coarse grid
used tracking the LLRF</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">complex array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_coarse_tot">
<code class="descname">V_coarse_tot</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_coarse_tot" title="Permalink to this definition">¶</a></dt>
<dd><p>Cavity voltage [V] at present turn in (I,Q) coordinates which is used
for tracking the LLRF</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">complex array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_fine_tot">
<code class="descname">V_fine_tot</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_fine_tot" title="Permalink to this definition">¶</a></dt>
<dd><p>Cavity voltage [V] at present turn in (I,Q) coordinates which is used
for tracking the beam</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">complex array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.a_comb">
<code class="descname">a_comb</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.a_comb" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursion constant of the comb filter; <span class="math notranslate nohighlight">\(a_{\mathsf{comb}}=15/16\)</span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.n_mov_av">
<code class="descname">n_mov_av</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.n_mov_av" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of points for moving average modelling cavity response;
<span class="math notranslate nohighlight">\(n_{\mathsf{mov.av.}} = \frac{f_r}{f_{\mathsf{bw,cav}}}\)</span>, where
<span class="math notranslate nohighlight">\(f_r\)</span> is the cavity resonant frequency of TWC_4 and TWC_5</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">const int</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.logger">
<code class="descname">logger</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>Logger of the present class</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">logger</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.beam_induced_voltage">
<code class="descname">beam_induced_voltage</code><span class="sig-paren">(</span><em>lpf=False</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.beam_induced_voltage" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the beam-induced voltage</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>lpf</strong> (<em>bool</em>) – Apply low-pass filter for beam current calculation;
default is False</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.I_beam">
<code class="descname">I_beam</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.I_beam" title="Permalink to this definition">¶</a></dt>
<dd><p>RF component of the beam charge [C] at the present time step</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">complex array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">V_coarse_ind_beam</code></dt>
<dd><p>Induced voltage [V] from beam-cavity interaction on the coarse grid</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">complex array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">V_fine_ind_beam</code></dt>
<dd><p>Induced voltage [V] from beam-cavity interaction on the fine grid</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">complex array</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.beam_induced_voltage_semi_analytic">
<code class="descname">beam_induced_voltage_semi_analytic</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.beam_induced_voltage_semi_analytic" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the beam-induced voltage in (I,Q) at the present carrier
frequency <span class="math notranslate nohighlight">\(\omega_c\)</span> using the semi-analytic method. It requires
that pre_compute_semi_analytic_factor() was called previously.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Beam-induced voltage in (I,Q) at <span class="math notranslate nohighlight">\(\omega_c\)</span></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">complex array [V]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.call_conv">
<code class="descname">call_conv</code><span class="sig-paren">(</span><em>signal</em>, <em>kernel</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.call_conv" title="Permalink to this definition">¶</a></dt>
<dd><p>Routine to call optimised C++ convolution</p>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.generator_induced_voltage">
<code class="descname">generator_induced_voltage</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.generator_induced_voltage" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the generator-induced voltage. The transmitter model is
a simple linear gain [C/V] converting voltage to charge.</p>
<div class="math notranslate nohighlight">
\[I = G_{\mathsf{tx}}\,\frac{V}{R_{\mathsf{gen}}} \, ,\]</div>
<p>where <span class="math notranslate nohighlight">\(R_{\mathsf{gen}}\)</span> is the generator resistance,
<code class="xref py py-attr docutils literal notranslate"><span class="pre">llrf.impulse_response.TravellingWaveCavity.R_gen</span></code></p>
<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.I_gen">
<code class="descname">I_gen</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.I_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>RF component of the generator charge [C] at the present time step</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">complex array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">V_coarse_ind_gen</code></dt>
<dd><p>Induced voltage [V] from generator-cavity interaction</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">complex array</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.induced_voltage">
<code class="descname">induced_voltage</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.induced_voltage" title="Permalink to this definition">¶</a></dt>
<dd><p>Generation of beam- or generator-induced voltage from the beam or
generator current, at a given carrier frequency and turn. The induced
voltage <span class="math notranslate nohighlight">\(V(t)\)</span> is calculated from the impulse response matrix
<span class="math notranslate nohighlight">\(h(t)\)</span> as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left( \begin{matrix} V_I(t) \\
V_Q(t) \end{matrix} \right)
= \left( \begin{matrix} h_s(t) &amp; - h_c(t) \\
h_c(t) &amp; h_s(t) \end{matrix} \right)
* \left( \begin{matrix} I_I(t) \\
I_Q(t) \end{matrix} \right) \, ,\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(*\)</span> denotes convolution,
<span class="math notranslate nohighlight">\(h(t)*x(t) = \int d\tau h(\tau)x(t-\tau)\)</span>. If the carrier
frequency is close to the cavity resonant frequency, <span class="math notranslate nohighlight">\(h_c = 0\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">See also:</th><td class="field-body"><code class="xref py py-class docutils literal notranslate"><span class="pre">llrf.impulse_response.TravellingWaveCavity</span></code></td>
</tr>
</tbody>
</table>
<p>The impulse response is made to be the same length as the beam profile.</p>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.llrf_model">
<code class="descname">llrf_model</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.llrf_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Models the LLRF part of the OTFB.</p>
<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_set">
<code class="descname">V_set</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.V_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Voltage set point [V] in (I,Q); <span class="math notranslate nohighlight">\(V_{\mathsf{set}}\)</span>, amplitude
proportional to voltage partition</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">complex array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.dV_gen">
<code class="descname">dV_gen</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.dV_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator voltage [V] in (I,Q);
<span class="math notranslate nohighlight">\(dV_{\mathsf{gen}} = V_{\mathsf{set}} - V_{\mathsf{tot}}\)</span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">complex array</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.matr_conv">
<code class="descname">matr_conv</code><span class="sig-paren">(</span><em>I</em>, <em>h</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.matr_conv" title="Permalink to this definition">¶</a></dt>
<dd><p>Convolution of beam current with impulse response; uses a complete
matrix with off-diagonal elements.</p>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.pre_compute_semi_analytic_factor">
<code class="descname">pre_compute_semi_analytic_factor</code><span class="sig-paren">(</span><em>time</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.pre_compute_semi_analytic_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Pre-computes factor for semi-analytic method, which is used to
compute the beam-induced voltage on the coarse grid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>time</strong> (<em>float array</em><em> [</em><em>s</em><em>]</em>) – Time array at which to compute the beam-induced voltage</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.profile_coarse">
<code class="descname">profile_coarse</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.profile_coarse" title="Permalink to this definition">¶</a></dt>
<dd><p>Beam profile with 20 bins per RF-bucket</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">class</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.semi_analytic_factor">
<code class="descname">semi_analytic_factor</code><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.semi_analytic_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Factor that is used to compute the beam-induced voltage</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">complex array [<span class="math notranslate nohighlight">\(\Omega\,s\)</span>]</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.track">
<code class="descname">track</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.track" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn-by-turn tracking method.</p>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.cavity_feedback.SPSOneTurnFeedback.track_no_beam">
<code class="descname">track_no_beam</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.cavity_feedback.SPSOneTurnFeedback.track_no_beam" title="Permalink to this definition">¶</a></dt>
<dd><p>Initial tracking method, before injecting beam.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-blond.llrf.impulse_response">
<span id="impulse-response-module"></span><h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">impulse_response</span></code> Module<a class="headerlink" href="#module-blond.llrf.impulse_response" title="Permalink to this headline">¶</a></h2>
<p><strong>Filters and methods for control loops</strong></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><strong>Helga Timko</strong></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="blond.llrf.impulse_response.SPS4Section200MHzTWC">
<em class="property">class </em><code class="descclassname">blond.llrf.impulse_response.</code><code class="descname">SPS4Section200MHzTWC</code><a class="headerlink" href="#blond.llrf.impulse_response.SPS4Section200MHzTWC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#blond.llrf.impulse_response.TravellingWaveCavity" title="blond.llrf.impulse_response.TravellingWaveCavity"><code class="xref py py-class docutils literal notranslate"><span class="pre">blond.llrf.impulse_response.TravellingWaveCavity</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="blond.llrf.impulse_response.SPS5Section200MHzTWC">
<em class="property">class </em><code class="descclassname">blond.llrf.impulse_response.</code><code class="descname">SPS5Section200MHzTWC</code><a class="headerlink" href="#blond.llrf.impulse_response.SPS5Section200MHzTWC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#blond.llrf.impulse_response.TravellingWaveCavity" title="blond.llrf.impulse_response.TravellingWaveCavity"><code class="xref py py-class docutils literal notranslate"><span class="pre">blond.llrf.impulse_response.TravellingWaveCavity</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity">
<em class="property">class </em><code class="descclassname">blond.llrf.impulse_response.</code><code class="descname">TravellingWaveCavity</code><span class="sig-paren">(</span><em>l_cell</em>, <em>N_cells</em>, <em>rho</em>, <em>v_g</em>, <em>omega_r</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Impulse responses of a travelling wave cavity. The induced voltage
<span class="math notranslate nohighlight">\(V(t)\)</span> from the impulse response <span class="math notranslate nohighlight">\(h(t)\)</span> and the I,Q (cavity or
generator) current <span class="math notranslate nohighlight">\(I(t)\)</span> can be written in matrix form,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left( \begin{matrix} V_I(t) \\
V_Q(t) \end{matrix} \right)
= \left( \begin{matrix} h_s(t) &amp; - h_c(t) \\
h_c(t) &amp; h_s(t) \end{matrix} \right)
* \left( \begin{matrix} I_I(t) \\
I_Q(t) \end{matrix} \right) \, ,\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(*\)</span> denotes convolution,
<span class="math notranslate nohighlight">\(h(t)*x(t) = \int d\tau h(\tau)x(t-\tau)\)</span>.</p>
<p>For the <strong>cavity-to-beam induced voltage</strong>, we define</p>
<div class="math notranslate nohighlight">
\[R_b \equiv \frac{\rho l^2}{8} \,\]</div>
<p>where <span class="math notranslate nohighlight">\(\rho\)</span> is the series impedance, <span class="math notranslate nohighlight">\(l\)</span> the accelerating
length, <span class="math notranslate nohighlight">\(\tau\)</span> the filling time. The cavity-to-beam wake is</p>
<div class="math notranslate nohighlight">
\[W_b(t) = \frac{4 R_b}{\tau} \mathsf{tri}\left(\frac{t}{\tau}\right)
 \cos(\omega_r t)\]</div>
<p>and the impulse response components are</p>
<div class="math notranslate nohighlight">
\[\begin{split}h_{s,b}(t) &amp;= \frac{2 R_b}{\tau} \mathsf{tri}\left(\frac{t}{\tau}\right)
 \cos((\omega_c - \omega_r)t) \, , \\
h_{c,b}(t) &amp;= \frac{2 R_b}{\tau} \mathsf{tri}\left(\frac{t}{\tau}\right)
\sin((\omega_c - \omega_r)t) \, ,\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathsf{tri}(x)\)</span> is the triangular function, <span class="math notranslate nohighlight">\(\omega_r\)</span>
is the central revolution frequency of the cavity, and <span class="math notranslate nohighlight">\(\omega_c\)</span> is
the carrier revolution frequency of the I,Q demodulated current signal. On
the carrier frequency, <span class="math notranslate nohighlight">\(\omega_c = \omega_r\)</span>,</p>
<div class="math notranslate nohighlight">
\[\begin{split}h_{s,b}(t) &amp;= \frac{2 R_b}{\tau} \mathsf{tri}\left(\frac{t}{\tau}\right) \\
h_{c,b}(t) &amp;= 0 \, .\end{split}\]</div>
<p>For the <strong>cavity-to-generator induced voltage</strong>, we define</p>
<div class="math notranslate nohighlight">
\[R_g \equiv l \sqrt{\frac{\rho Z_0}{2}} \,\]</div>
<p>where <span class="math notranslate nohighlight">\(Z_0\)</span> is the shunt impedance when measuring the generator
current; assumed to be 50 <span class="math notranslate nohighlight">\(\Omega\)</span>. The cavity-to-generator wake is</p>
<div class="math notranslate nohighlight">
\[W_g(t) = \frac{2 R_g}{\tau} \mathsf{rect}\left(\frac{t}{\tau}\right)
\cos(\omega_r t)\]</div>
<p>and the impulse response components are</p>
<div class="math notranslate nohighlight">
\[\begin{split}h_{s,g}(t) &amp;= \frac{R_g}{\tau} \mathsf{rect}\left(\frac{t}{\tau}\right)
\cos((\omega_c - \omega_r)t) \, , \\
h_{c,g}(t) &amp;= \frac{R_g}{\tau} \mathsf{rect}\left(\frac{t}{\tau}\right)
\sin((\omega_c - \omega_r)t) \, ,\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathsf{rect}(x)\)</span> is the rectangular function. On the carrier
frequency, <span class="math notranslate nohighlight">\(\omega_c = \omega_r\)</span>,</p>
<div class="math notranslate nohighlight">
\[\begin{split}h_{s,g}(t) &amp;= \frac{R_g}{\tau} \mathsf{rect}\left(\frac{t}{\tau}\right) \\
h_{c,g}(t) &amp;= 0 \, .\end{split}\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>l_cell</strong> (<em>float</em>) – Cavity cell length [m]</li>
<li><strong>N_cells</strong> (<em>int</em>) – Number of accelerating (interacting) cells in a cavity</li>
<li><strong>rho</strong> (<em>float</em>) – Series impedance [Ohms/m^2] of the cavity</li>
<li><strong>v_g</strong> (<em>float</em>) – Group velocity [c] in units of the speed of light</li>
<li><strong>omega_r</strong> (<em>flaot</em>) – Central (resonance) revolution frequency [1/s] of the cavity</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.Z_0">
<code class="descname">Z_0</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.Z_0" title="Permalink to this definition">¶</a></dt>
<dd><p>Shunt impedance of generator current measurement; assumed to be 50 Ohms</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.R_beam">
<code class="descname">R_beam</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.R_beam" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math notranslate nohighlight">\(R_b\)</span> [Omega] as defined above</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.R_gen">
<code class="descname">R_gen</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.R_gen" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math notranslate nohighlight">\(R_g\)</span> [Omega] as defined above</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.l_cav">
<code class="descname">l_cav</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.l_cav" title="Permalink to this definition">¶</a></dt>
<dd><p>Length [m] of the interaction region</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.tau">
<code class="descname">tau</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.tau" title="Permalink to this definition">¶</a></dt>
<dd><p>Cavity filling time [s]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.compute_wakes">
<code class="descname">compute_wakes</code><span class="sig-paren">(</span><em>time</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.compute_wakes" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the wake fields towards the beam and generator on the
central cavity frequency.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>time_beam</strong> (<em>float</em>) – Time array of the beam to act on</li>
<li><strong>time_gen</strong> (<em>float</em>) – Time array of the generator to act on</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.W_beam">
<code class="descname">W_beam</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.W_beam" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math notranslate nohighlight">\(W_b(t)\)</span> [Omega/s] as defined above</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">float array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.W_gen">
<code class="descname">W_gen</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.W_gen" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math notranslate nohighlight">\(W_g(t)\)</span> [Omega/s] as defined above</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">float array</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.impulse_response_beam">
<code class="descname">impulse_response_beam</code><span class="sig-paren">(</span><em>omega_c</em>, <em>time_fine</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.impulse_response_beam" title="Permalink to this definition">¶</a></dt>
<dd><p>Impulse response from the cavity towards the beam. For a signal
that is I,Q demodulated at a given carrier
frequency <span class="math notranslate nohighlight">\(\omega_c\)</span>. The formulae assume that the carrier
frequency is be close to the central frequency
<span class="math notranslate nohighlight">\(\omega_c/\omega_r \ll 1\)</span> and that the signal is low-pass
filtered (i.e.high-frequency components can be neglected).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>omega_c</strong> (<em>float</em>) – Carrier revolution frequency [1/s]</li>
<li><strong>time_fine</strong> (<em>float</em>) – Time array of the beam profile to act on</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.d_omega">
<code class="descname">d_omega</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.d_omega" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math notranslate nohighlight">\(\omega_c - \omega_r\)</span> [1/s]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.t_beam">
<code class="descname">t_beam</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.t_beam" title="Permalink to this definition">¶</a></dt>
<dd><p>time array for beam wake and impulse response; starts from zero</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">float array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.hs_beam">
<code class="descname">hs_beam</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.hs_beam" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math notranslate nohighlight">\(h_{s,b}(t)\)</span> [Omega/s] as defined above</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">float array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.hc_beam">
<code class="descname">hc_beam</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.hc_beam" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math notranslate nohighlight">\(h_{c,b}(t)\)</span> [Omega/s] as defined above</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">float array</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.impulse_response_gen">
<code class="descname">impulse_response_gen</code><span class="sig-paren">(</span><em>omega_c</em>, <em>time_coarse</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.impulse_response_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Impulse response from the cavity towards the
generator. For a signal that is I,Q demodulated at a given carrier
frequency <span class="math notranslate nohighlight">\(\omega_c\)</span>. The formulae assume that the carrier
frequency is be close to the central frequency
<span class="math notranslate nohighlight">\(\omega_c/\omega_r \ll 1\)</span> and that the signal is low-pass
filtered (i.e.high-frequency components can be neglected).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>omega_c</strong> (<em>float</em>) – Carrier revolution frequency [1/s]</li>
<li><strong>time_coarse</strong> (<em>float</em>) – Time array of the LLRF to act on</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt>
<code class="descname">d_omega</code></dt>
<dd><p><span class="math notranslate nohighlight">\(\omega_c - \omega_r\)</span> [1/s]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.t_gen">
<code class="descname">t_gen</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.t_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>time array for generator wake and impulse response; starts from
<span class="math notranslate nohighlight">\(- \tau/2\)</span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">float array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.hs_gen">
<code class="descname">hs_gen</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.hs_gen" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math notranslate nohighlight">\(h_{s,g}(t)\)</span> [Omega/s] as defined above</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">float array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="blond.llrf.impulse_response.TravellingWaveCavity.hc_gen">
<code class="descname">hc_gen</code><a class="headerlink" href="#blond.llrf.impulse_response.TravellingWaveCavity.hc_gen" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="math notranslate nohighlight">\(h_{c,g}(t)\)</span> [Omega/s] as defined above</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">float array</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="function">
<dt id="blond.llrf.impulse_response.rectangle">
<code class="descclassname">blond.llrf.impulse_response.</code><code class="descname">rectangle</code><span class="sig-paren">(</span><em>t</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.impulse_response.rectangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Rectangular function of time</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathsf{rect} \left( \frac{t}{\tau} \right) =
\begin{cases}
    1 \, , \, t \in (-\tau/2, \tau/2) \\
    0.5 \, , \, t = \pm \tau/2 \\
    0 \, , \, \textsf{otherwise}
\end{cases}\end{split}\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>t</strong> (<em>float array</em>) – Time array</li>
<li><strong>tau</strong> (<em>float</em>) – Time window of rectangular function</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Rectangular function for given time array</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">float array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="blond.llrf.impulse_response.triangle">
<code class="descclassname">blond.llrf.impulse_response.</code><code class="descname">triangle</code><span class="sig-paren">(</span><em>t</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.impulse_response.triangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Triangular function of time</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathsf{tri} \left( \frac{t}{\tau} \right) =
\begin{cases}
    1 - \frac{t}{\tau}\, , \, t \in (0, \tau) \\
    0.5 \, , \, t = 0 \\
    0 \, , \, \textsf{otherwise}
\end{cases}\end{split}\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>t</strong> (<em>float array</em>) – Time array</li>
<li><strong>tau</strong> (<em>float</em>) – Time window of rectangular function</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Triangular function for given time array</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">float array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-blond.llrf.rf_modulation">
<span id="rf-modulation-module"></span><h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">rf_modulation</span></code> Module<a class="headerlink" href="#module-blond.llrf.rf_modulation" title="Permalink to this headline">¶</a></h2>
<p><strong>Methods to generate RF phase modulation from given frequency, amplitude
and offset functions</strong></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><strong>Simon Albright</strong></td>
</tr>
</tbody>
</table>
<dl class="function">
<dt id="blond.llrf.rf_modulation.ModulateHarmonic">
<code class="descclassname">blond.llrf.rf_modulation.</code><code class="descname">ModulateHarmonic</code><span class="sig-paren">(</span><em>Ring</em>, <em>RFStation</em>, <em>modulationList</em>, <em>harmonic</em>, <em>includeFreq=True</em>, <em>preshift=0</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.rf_modulation.ModulateHarmonic" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to apply modulation(s) to RFStation
modulationList is a list of modulation objects applied
sequentially to RFStation.</p>
<p>harmonicList specifies which harmonic of RFStation
will be modulated</p>
<p>includeFreq flag determines if effect of modulation on
RF frequency should be included.  False will treat
modulation as pure phase shift, True will include the
small frequency shift needed to adjust the phase.</p>
</dd></dl>

<dl class="class">
<dt id="blond.llrf.rf_modulation.PhaseModulation">
<em class="property">class </em><code class="descclassname">blond.llrf.rf_modulation.</code><code class="descname">PhaseModulation</code><span class="sig-paren">(</span><em>frequency</em>, <em>amplitude</em>, <em>offset</em>, <em>time</em>, <em>freqMultiplier=1</em>, <em>interpType='cubic'</em>, <em>smoothing=1000</em>, <em>ontime=0</em>, <em>offtime=0</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.rf_modulation.PhaseModulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

</div>
<div class="section" id="llrf-rf-noise-module">
<h2>llrf.rf_noise Module<a class="headerlink" href="#llrf-rf-noise-module" title="Permalink to this headline">¶</a></h2>
<p><strong>Methods to generate RF phase noise from noise spectrum and feedback noise
amplitude as a function of bunch length</strong></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><strong>Helga Timko</strong></td>
</tr>
</tbody>
</table>
<div class="section" id="rf-phase-noise-generation">
<h3>RF phase noise generation<a class="headerlink" href="#rf-phase-noise-generation" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="blond.llrf.rf_modulation.llrf.rf_noise.PhaseNoise">
<em class="property">class </em><code class="descclassname">llrf.rf_noise.</code><code class="descname">PhaseNoise</code><span class="sig-paren">(</span><em>object).__init__(frequency_array</em>, <em>real_part_of_spectrum</em>, <em>seed1=None</em>, <em>seed2=None</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.rf_modulation.llrf.rf_noise.PhaseNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains the spectrum of RF phase noise and the actual phase noise randomly
generated from it. Generation done via mixing with white noise.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>frequency_array</strong> (<em>numpy.array</em>) – input frequency range</li>
<li><strong>real_part_of_spectrum</strong> (<em>numpy.array</em>) – input spectrum, real part only,
same length as <code class="docutils literal notranslate"><span class="pre">frequency_array</span></code></li>
<li><strong>seed1</strong> (<em>int</em>) – seed for random number generator</li>
<li><strong>seed2</strong> (<em>int</em>) – seed for random number generator</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The spectrum has to be input as double-sided spectrum, in units
of [<span class="math notranslate nohighlight">\(\text{rad}^2/\text{Hz}\)</span>].</p>
</div>
<p>Both hermitian to real and complex to complex FFTs are available. Use seeds
to fix a certain random number sequence; with <code class="docutils literal notranslate"><span class="pre">seed=None</span></code> a random sequence
will be initialized.</p>
<dl class="method">
<dt id="blond.llrf.rf_modulation.llrf.rf_noise.PhaseNoise.spectrum_to_phase_noise">
<code class="descname">spectrum_to_phase_noise</code><span class="sig-paren">(</span><em>transform=None</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.rf_modulation.llrf.rf_noise.PhaseNoise.spectrum_to_phase_noise" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms a noise spectrum to phase noise data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>transform</strong> (<em>choice</em>) – FFT transform kind</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">time and phase noise arrays</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">transform=None</span></code> or <code class="docutils literal notranslate"><span class="pre">'r'</span></code> to transform hermitian
spectrum to real phase. In this case, input only the positive part of
the double-sided spectrum. Use <code class="docutils literal notranslate"><span class="pre">transform='c'</span></code> to transform complex
spectrum to complex phase. In this case, input first the zero and
positive frequency components, then the decreasingly negative frequency
components of the double-sided spectrum. Returns only the real part of
the phase noise. E.g. the following two ways of usage are equivalent:</p>
<a class="last reference internal image-reference" href="../_images/RF_noise.png"><img alt="../_images/RF_noise.png" class="align-center" src="../_images/RF_noise.png" style="width: 1000px; height: 250px;" /></a>
</div>
<p><strong>The transformation in steps</strong></p>
<p><strong>Step 1:</strong> Set the resolution in time domain. To transform a hermitian
spectrum to real phase noise,</p>
<div class="math notranslate nohighlight">
\[n_t = 2 (n_f - 1) \text{\,\,and\,\,} \Delta t = 1/(2 f_{\text{max}}) ,\]</div>
<p>and to transform a complex spectrum to complex phase noise,</p>
<div class="math notranslate nohighlight">
\[n_t = n_f \text{\,\,and\,\,} \Delta t = 1/f_{\text{max}} ,\]</div>
<p>where <code class="docutils literal notranslate"><span class="pre">fmax</span></code> is the maximum frequency in the input in both cases.</p>
<p><strong>Step 2:</strong> Generate white (carrier) noise in time domain</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}w_k(t) = \cos(2 \pi r_k^{(1)}) \sqrt{-2 \ln(r_k^{(2)})} \text{\,\,\,case `r'},\\w_k(t) = \exp(2 \pi i r_k^{(1)}) \sqrt{-2 \ln(r_k^{(2)})} \text{\,\,\,case `c'},\end{aligned}\end{align} \]</div>
<p><strong>Step 3:</strong> Transform the generated white noise to frequency domain</p>
<div class="math notranslate nohighlight">
\[W_l(f) = \sum_{k=1}^N w_k(t) e^{-2 \pi i \frac{k l}{N}} .\]</div>
<p><strong>Step 4:</strong> In frequency domain, colour the white noise with the desired
noise probability density (unit: radians). The noise probability density
derived from the double-sided spectrum is</p>
<div class="math notranslate nohighlight">
\[s_l(f) = \sqrt{A S_l^{\text{DB}} f_{\text{max}}} ,\]</div>
<p>where <span class="math notranslate nohighlight">\(A=2\)</span> for <code class="docutils literal notranslate"><span class="pre">transform</span> <span class="pre">=</span> <span class="pre">'r'</span></code> and <span class="math notranslate nohighlight">\(A=1\)</span> for
<code class="docutils literal notranslate"><span class="pre">transform</span> <span class="pre">=</span> <span class="pre">'c'</span></code>. The coloured noise is obtained by multiplication in
frequency domain</p>
<div class="math notranslate nohighlight">
\[\Phi_l(f) = s_l(f) W_l(f) .\]</div>
<p><strong>Step 5:</strong> Transform back the coloured spectrum to time domain to obtain
the final phase shift array (we use only the real part).</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="lhc-type-phase-noise-generation">
<h3>LHC-type phase noise generation<a class="headerlink" href="#lhc-type-phase-noise-generation" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="blond.llrf.rf_modulation.llrf.rf_noise.LHCFlatSpectrum">
<em class="property">class </em><code class="descclassname">llrf.rf_noise.</code><code class="descname">LHCFlatSpectrum</code><span class="sig-paren">(</span><em>object).__init__(GeneralParameters</em>, <em>RFSectionParameters</em>, <em>time_points</em>, <em>corr_time = 10000</em>, <em>fmin = 0.8571</em>, <em>fmax = 1.1</em>, <em>initial_amplitude = 1.e-6</em>, <em>seed1 = 1234</em>, <em>seed2 = 7564</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.rf_modulation.llrf.rf_noise.LHCFlatSpectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates LHC-type phase noise from a band-limited spectrum. Input frequency
band using <code class="docutils literal notranslate"><span class="pre">fmin</span></code> and <code class="docutils literal notranslate"><span class="pre">fmax</span></code> w.r.t. the synchrotron frequency. Input
double-sided spectrum amplitude [<span class="math notranslate nohighlight">\(\text{rad}^2/\text{Hz}\)</span>] using
<code class="docutils literal notranslate"><span class="pre">initial_amplitude</span></code>. Fix seeds to obtain reproducible phase noise. Select
<code class="docutils literal notranslate"><span class="pre">time_points</span></code> suitably to resolve the spectrum in frequency domain. After
<code class="docutils literal notranslate"><span class="pre">corr_time</span></code> turns, the seed is changed (reproducibly) to cut numerical
correlated sequences of the random number generator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>GeneralParameters</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">input_parameters.general_parameters.GeneralParameters</span></code></li>
<li><strong>RFSectionParameters</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">input_parameters.rf_parameters.RFSectionParameters</span></code></li>
<li><strong>time_points</strong> (<em>int</em>) – number of phase noise points of a sample in time
domain</li>
<li><strong>corr_time</strong> (<em>int</em>) – number of turns after which seed is changed</li>
<li><strong>fmin</strong> (<em>double</em>) – spectrum lower limit in units of synchrotron frequency</li>
<li><strong>fmax</strong> (<em>double</em>) – spectrum upper limit in units of synchrotron frequency</li>
<li><strong>initial_amplitude</strong> (<em>double</em>) – initial double sided spectral density
[<span class="math notranslate nohighlight">\(\text{rad}^2/\text{Hz}\)</span>]</li>
<li><strong>seed1</strong> (<em>int</em>) – seed for random number generator</li>
<li><strong>seed2</strong> (<em>int</em>) – seed for random number generator</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">time_points</span></code> should be chosen large enough to resolve the
desired frequency step <span class="math notranslate nohighlight">\(\Delta f =\)</span>
<code class="xref py py-attr docutils literal notranslate"><span class="pre">GeneralParameters.f_rev</span></code>/<code class="xref py py-attr docutils literal notranslate"><span class="pre">LHCFlatSpectrum.time_points</span></code>
in frequency domain.</p>
</div>
<dl class="method">
<dt id="blond.llrf.rf_modulation.llrf.rf_noise.LHCFlatSpectrum.generate">
<code class="descname">generate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.rf_modulation.llrf.rf_noise.LHCFlatSpectrum.generate" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates LHC-type phase noise array (length:
<code class="xref py py-attr docutils literal notranslate"><span class="pre">GeneralParameters.n_turns</span></code> + 1). Stored in the variable
<code class="xref py py-attr docutils literal notranslate"><span class="pre">LHCFlatSpectrum.dphi</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="bunch-length-based-feedback-on-noise-amplitude">
<h3>Bunch-length based feedback on noise amplitude<a class="headerlink" href="#bunch-length-based-feedback-on-noise-amplitude" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="blond.llrf.rf_modulation.llrf.rf_noise.LHCNoiseFB">
<em class="property">class </em><code class="descclassname">llrf.rf_noise.</code><code class="descname">LHCNoiseFB</code><span class="sig-paren">(</span><em>object).__init__(bl_target</em>, <em>gain = 1.5</em>, <em>factor = 0.8</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.rf_modulation.llrf.rf_noise.LHCNoiseFB" title="Permalink to this definition">¶</a></dt>
<dd><p>Feedback on phase noise amplitude for LHC controlled longitudinal emittance
blow-up using noise injection through cavity controller or phase loop.
The feedback compares the FWHM bunch length of the bunch to a target value
and scales the phase noise to keep the targeted value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>bl_target</strong> – Targeted 4-sigma-equivalent FWHM bunch length [ns]</li>
<li><strong>gain</strong> – feedback gain [1/ns]</li>
<li><strong>factor</strong> – feedback recursion scaling factor [1]</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Note that the FWMH bunch length is scaled by
<span class="math notranslate nohighlight">\(\sqrt{2/\ln{2}}\)</span> in order to obtain a 4-sigma equivalent value.</p>
</div>
<dl class="method">
<dt id="blond.llrf.rf_modulation.llrf.rf_noise.LHCNoiseFB.FB">
<code class="descname">FB</code><span class="sig-paren">(</span><em>RFSectionParameters</em>, <em>Beam</em>, <em>PhaseNoise</em>, <em>Slices</em>, <em>CC = False</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.rf_modulation.llrf.rf_noise.LHCNoiseFB.FB" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the bunch-length based feedback scaling factor as a function
of measured FWHM bunch length. For phase noise injected through the
cavity RF voltage, the feedback scaling can be directly applied on the
<code class="xref py py-attr docutils literal notranslate"><span class="pre">RFSectionParameters.phi_noise</span></code> variable by setting
<code class="docutils literal notranslate"><span class="pre">CC</span> <span class="pre">=</span> <span class="pre">True</span></code>. For phase noise injected through the <code class="xref py py-class docutils literal notranslate"><span class="pre">PhaseLoop</span></code>
class, the correction can be applied inside the phase loop, via passing
<code class="xref py py-class docutils literal notranslate"><span class="pre">LHCNoiseFB</span></code> as an argument in <code class="xref py py-class docutils literal notranslate"><span class="pre">PhaseLoop</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>RFSectionParameters</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">input_parameters.rf_parameters.RFSectionParameters</span></code></li>
<li><strong>Beam</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">beams.beams.Beam</span></code></li>
<li><strong>PhaseNoise</strong> – phase-noise type class,
<a class="reference internal" href="#blond.llrf.rf_modulation.llrf.rf_noise.PhaseNoise" title="blond.llrf.rf_modulation.llrf.rf_noise.PhaseNoise"><code class="xref py py-class docutils literal notranslate"><span class="pre">llrf.rf_noise.PhaseNoise</span></code></a> or
<a class="reference internal" href="#blond.llrf.rf_modulation.llrf.rf_noise.LHCFlatSpectrum" title="blond.llrf.rf_modulation.llrf.rf_noise.LHCFlatSpectrum"><code class="xref py py-class docutils literal notranslate"><span class="pre">llrf.rf_noise.LHCFlatSpectrum</span></code></a></li>
<li><strong>Slices</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">beams.slices.Slices</span></code></li>
<li><strong>CC</strong> (<em>bool</em>) – cavity controller option</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="classmethod">
<dt id="blond.llrf.rf_modulation.fwhm">
<em class="property">classmethod </em><code class="descclassname">blond.llrf.rf_modulation.</code><code class="descname">fwhm</code><span class="sig-paren">(</span><em>Slices</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.rf_modulation.fwhm" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast FWHM bunch length calculation with slice width precision.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>Slices</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">beams.slices.Slices</span></code></td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">4-sigma-equivalent FWHM bunch length [ns]</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-blond.llrf.signal_processing">
<span id="signal-processing-module"></span><h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal_processing</span></code> Module<a class="headerlink" href="#module-blond.llrf.signal_processing" title="Permalink to this headline">¶</a></h2>
<p><strong>Filters and methods for control loops</strong></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body"><strong>Helga Timko</strong></td>
</tr>
</tbody>
</table>
<dl class="function">
<dt id="blond.llrf.signal_processing.cartesian_to_polar">
<code class="descclassname">blond.llrf.signal_processing.</code><code class="descname">cartesian_to_polar</code><span class="sig-paren">(</span><em>IQ_vector</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.signal_processing.cartesian_to_polar" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert data from Cartesian (I,Q) to polar coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>IQ_vector</strong> (<em>complex array</em>) – Signal with in-phase and quadrature (I,Q) components</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="simple">
<li><em>float array</em> – Amplitude of signal</li>
<li><em>float array</em> – Phase of signal</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="blond.llrf.signal_processing.comb_filter">
<code class="descclassname">blond.llrf.signal_processing.</code><code class="descname">comb_filter</code><span class="sig-paren">(</span><em>y</em>, <em>x</em>, <em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.signal_processing.comb_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Feedback comb filter.</p>
</dd></dl>

<dl class="function">
<dt id="blond.llrf.signal_processing.low_pass_filter">
<code class="descclassname">blond.llrf.signal_processing.</code><code class="descname">low_pass_filter</code><span class="sig-paren">(</span><em>signal</em>, <em>cutoff_frequency=0.5</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.signal_processing.low_pass_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Low-pass filter based on Butterworth 5th order digital filter from
scipy,
<a class="reference external" href="http://docs.scipy.org">http://docs.scipy.org</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>signal</strong> (<em>float array</em>) – Signal to be filtered</li>
<li><strong>cutoff_frequency</strong> (<em>float</em>) – Cutoff frequency [1] corresponding to a 3 dB gain drop, relative to the
Nyquist frequency of 1; default is 0.5</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Low-pass filtered signal</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">float array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="blond.llrf.signal_processing.modulator">
<code class="descclassname">blond.llrf.signal_processing.</code><code class="descname">modulator</code><span class="sig-paren">(</span><em>signal</em>, <em>omega_i</em>, <em>omega_f</em>, <em>T_sampling</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.signal_processing.modulator" title="Permalink to this definition">¶</a></dt>
<dd><p>Demodulate a signal from initial frequency to final frequency. The two
frequencies should be close.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>signal</strong> (<em>float array</em>) – Signal to be demodulated</li>
<li><strong>omega_i</strong> (<em>float</em>) – Initial revolution frequency [1/s] of signal (before demodulation)</li>
<li><strong>omega_f</strong> (<em>float</em>) – Final revolution frequency [1/s] of signal (after demodulation)</li>
<li><strong>T_sampling</strong> (<em>float</em>) – Sampling period (temporal bin size) [s] of the signal</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Demodulated signal at f_final</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">float array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="blond.llrf.signal_processing.moving_average">
<code class="descclassname">blond.llrf.signal_processing.</code><code class="descname">moving_average</code><span class="sig-paren">(</span><em>x</em>, <em>N</em>, <em>x_prev=None</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.signal_processing.moving_average" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to calculate the moving average (or running mean) of the input
data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>float array</em>) – Data to be smoothed</li>
<li><strong>N</strong> (<em>int</em>) – Window size in points</li>
<li><strong>x_prev</strong> (<em>float array</em>) – Data to pad with in front</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><dl class="docutils">
<dt>Smoothed data array of size</dt>
<dd><ul class="first last simple">
<li>len(x) - N + 1, if x_prev = None</li>
<li>len(x) + len(x_prev) - N + 1, if x_prev given</li>
</ul>
</dd>
</dl>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">float array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="blond.llrf.signal_processing.polar_to_cartesian">
<code class="descclassname">blond.llrf.signal_processing.</code><code class="descname">polar_to_cartesian</code><span class="sig-paren">(</span><em>amplitude</em>, <em>phase</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.signal_processing.polar_to_cartesian" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert data from polar to cartesian (I,Q) coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>amplitude</strong> (<em>float array</em>) – Amplitude of signal</li>
<li><strong>phase</strong> (<em>float array</em>) – Phase of signal</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Signal with in-phase and quadrature (I,Q) components</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">complex array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="blond.llrf.signal_processing.rf_beam_current">
<code class="descclassname">blond.llrf.signal_processing.</code><code class="descname">rf_beam_current</code><span class="sig-paren">(</span><em>Profile</em>, <em>omega_c</em>, <em>T_rev</em>, <em>lpf=True</em><span class="sig-paren">)</span><a class="headerlink" href="#blond.llrf.signal_processing.rf_beam_current" title="Permalink to this definition">¶</a></dt>
<dd><p>Function calculating the beam charge at the (RF) frequency, slice by
slice. The charge distribution [C] of the beam is determined from the beam
profile <span class="math notranslate nohighlight">\(\lambda_i\)</span>, the particle charge <span class="math notranslate nohighlight">\(q_p\)</span> and the real vs.
macro-particle ratio <span class="math notranslate nohighlight">\(N_{\mathsf{real}}/N_{\mathsf{macro}}\)</span></p>
<div class="math notranslate nohighlight">
\[Q_i = \frac{N_{\mathsf{real}}}{N_{\mathsf{macro}}} q_p \lambda_i\]</div>
<p>The total charge [C] in the beam is then</p>
<div class="math notranslate nohighlight">
\[Q_{\mathsf{tot}} = \sum_i{Q_i}\]</div>
<p>The DC beam current [A] is the total number of charges per turn <span class="math notranslate nohighlight">\(T_0\)</span></p>
<div class="math notranslate nohighlight">
\[I_{\mathsf{DC}} = \frac{Q_{\mathsf{tot}}}{T_0}\]</div>
<p>The RF beam charge distribution [C] at a revolution frequency
<span class="math notranslate nohighlight">\(\omega_c\)</span> is the complex quantity</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left( \begin{matrix} I_{rf,i} \\
Q_{rf,i} \end{matrix} \right)
= 2 Q_i \left( \begin{matrix} \cos(\omega_c t_i) \\
\sin(\omega_c t_i)\end{matrix} \right) \, ,\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(t_i\)</span> are the time coordinates of the beam profile. After de-
modulation, a low-pass filter at 20 MHz is applied.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Profile</strong> (<em>class</em>) – A Profile type class</li>
<li><strong>omega_c</strong> (<em>float</em>) – Revolution frequency [1/s] at which the current should be calculated</li>
<li><strong>T_rev</strong> (<em>float</em>) – Revolution period [s] of the machine</li>
<li><strong>lpf</strong> (<em>bool</em>) – Apply low-pass filter; default is True</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">RF beam charge array [C] at ‘frequency’ omega_c. To obtain current,
divide by the sampling time</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">complex array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="monitors.html" class="btn btn-neutral float-right" title="monitors Package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="input_parameters.html" class="btn btn-neutral" title="input_parameters Package" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
   

</body>
</html>